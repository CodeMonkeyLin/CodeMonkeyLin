[{"title":"正则表达式","date":"2018-01-17T09:22:25.000Z","path":"2018/01/17/vue国际化高逼格/","text":"摘要: vue多语言的设置 1.NPM 项目安装 1cnpm i vue-i18n 2.使用方法1234567891011121314151617181920212223242526272829303132/* 国际化使用规则 */import Vue from &apos;vue&apos;import VueI18n from &apos;vue-i18n&apos;Vue.use(VueI18n)const messages = &#123; en: &#123; message: &#123; hello: &apos;world hello&apos; &#125; &#125;, zh: &#123; message: &#123; hello: &apos;世界&apos; &#125; &#125;&#125;const i18n = new VueI18n(&#123; locale: &apos;zh&apos;, messages&#125;)export default &#123; data () &#123; return &#123; hello: this.$t(&apos;message.hello&apos;) &#125; &#125;, i18n&#125; 数据使用123&lt;div id=&quot;#app&quot;&gt; &lt;p&gt;&#123;&#123; $t(&quot;message.hello&quot;) &#125;&#125;&lt;/p&gt;&lt;/div&gt;","tags":[{"name":"vue","slug":"vue","permalink":"http://liufusong.github.io/tags/vue/"}]},{"title":"托管静态网站surge","date":"2018-01-13T09:22:25.000Z","path":"2018/01/13/托管静态网站surge/","text":"摘要: 托管静态网站surge surge是一款开发的网络调试工具，较适用于开发人员 第一步：安装surge安装命令：npm i surge -g 第二步：建立一个需要托管的项目文件夹看你心情随便找一个地方建立一个任意名字的文件夹，将需要托管的静态资源放进去就可以 第三步：开启服务在项目根目录输入surge命令后会提示输入邮箱，密码，输入即可，然后一路回车 最后会看见一个临时域名即可访问","tags":[{"name":"正则","slug":"正则","permalink":"http://liufusong.github.io/tags/正则/"}]},{"title":"vue引入全局js","date":"2017-11-06T01:59:52.000Z","path":"2017/11/06/vue引入全局js/","text":"摘要: github 如何在全局引入公共的js1、建立你的公共js取名common.js（你自己取名随意啦只要对应即可）并导出 例如： 12345export default&#123; test:function()&#123; console.log(&quot;这是一个公共的js&quot;) &#125;&#125; 2、在main.js中导入文件 1import common from &apos;./kits/common.js&apos;; 3、添加到Vue的原型中 1Vue.prototype.$common = common; 4、在其他js组件中即可使用 123created()&#123; this.$common(); &#125; 噢耶轻松搞定！！！！！！！","tags":[{"name":"-vue","slug":"vue","permalink":"http://liufusong.github.io/tags/vue/"}]},{"title":"sublime快捷键汇总","date":"2017-07-18T12:03:36.000Z","path":"2017/07/18/sublime快捷键汇总/","text":"摘要：sublime快捷键 常用 Tab 自动补全 Ctrl + ` 打开控制台 Ctrl + Z 撤销 Ctrl + Y 前进 换行 Ctrl + Enter 在当前行下面新增一行然后跳至该行 Ctrl + Shift + Enter 在当前行上面增加一行并跳至该行 Ctrl + Shift + ←/→ 进行逐词选择 Ctrl + Shift + ↑/↓ 移动 当前行 Ctrl + ←/→ 进行逐词 移动 Ctrl + ↑/↓ 移动 当前显示区域 多重选择（应用场景-重命名） Ctrl + D 选择当前光标所在的词并高亮该词所有出现的位置， 再次Ctrl + D 选择该词出现的下一个位置，在多重选词的过程中 使用Ctrl + K 进行跳过 使用Ctrl + U 进行回退 使用Esc退出多重编辑 同时编辑与合并 Ctrl + Shift + L可以将当前选中区域打散，然后进行同时编辑 Ctrl + J可以把当前选中区域合并为一行 快速查找&amp;替换 Shift + ←/→或Ctrl + D选中关键字，然后 F3 跳到其下一个出现位置， Shift + F3 跳到其上一个出现位置，此外还可以用 Alt + F3 选中其出现的所有位置（之后可以进行多重编辑，也就是快速替换） 标准查找&amp;替换 Ctrl + F 调出搜索框进行搜索 Enter 跳至关键字当前光标的下一个位置 Shift + Enter 跳至上一个位置， Alt + Enter 选中其出现的所有位置（同样的，接下来可以进行快速替换） 查找有不同的模式 Alt + C 切换大小写敏感（Case-sensitive）模式 Alt + W 切换整字匹配（Whole matching）模式 还支持在选中范围内搜索（Search in selection），这个功能没有对应的快捷键，但可以通过以下配置项自动开启。这样之后在选中文本的状态下范围内搜索就会自动开启，配合这个功能，局部重命名（Local Renaming）变的非常方便“auto_find_in_selection”: true 分屏 Alt + Shift + 1 取消分屏 Alt + Shift + 2 进行左右2分屏 Alt + Shift + 3 进行左右3分屏 Alt + Shift + 4 进行左右4分屏 Alt + Shift + 5 进行上下左右4分屏 Alt + Shift + 8 进行上下2分屏 Alt + Shift + 9 进行上下3分屏 Ctrl + 1/2/3/4 数字键跳转到指定屏 Ctrl + Shift + 1/2/3/4 数字键将当前屏移动到指定屏 标签（Tab） Ctrl + N 在当前窗口创建一个新标签 Ctrl + W 关闭当前标签 Ctrl + Shift + T 恢复刚刚关闭的标签 窗口（Window） Ctrl + Shift + N 创建一个新窗口（该快捷键再次和搜狗输入法快捷键冲突，个人建议禁用所有搜狗输入法快捷键）。 当窗口内没有标签时， 使用Ctrl + W 关闭该窗口","tags":[{"name":"sublime","slug":"sublime","permalink":"http://liufusong.github.io/tags/sublime/"},{"name":"命令","slug":"命令","permalink":"http://liufusong.github.io/tags/命令/"}]},{"title":"vue-cli初始化大型项目","date":"2017-07-18T12:03:36.000Z","path":"2017/07/18/vue-cli/","text":"摘要：vue-cli 1、在cmd命令面板中执行：npm install –global vue-cli 全局安装 vue-cli 2、利用：vue init webpack projectName(自定义项目名称) 创建一个基于webpack模板的新项目 3、进入到项目名称文件夹中执行 npm install 安装项目所需依赖 4、运行 npm run dev 运行项目","tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"http://liufusong.github.io/tags/vue-cli/"},{"name":"命令","slug":"命令","permalink":"http://liufusong.github.io/tags/命令/"}]},{"title":"vue文件代码高亮设置","date":"2017-07-16T15:18:54.000Z","path":"2017/07/16/vue文件代码高亮设置/","text":"摘要: github 准备语法高亮插件vue-syntax-highlight1、下载地址http://git.oschina.net/destiny001/vue-syntax-highlight-master 2、点击菜单栏首选项&gt;浏览插件 3、将下载的压缩包解压后放在本地插件库里即可","tags":[{"name":"vue","slug":"vue","permalink":"http://liufusong.github.io/tags/vue/"}]},{"title":"sublime 插件配置","date":"2017-06-21T03:57:15.000Z","path":"2017/06/21/sublime插件配置/","text":"摘要： sublime 插件配置 配置Terminal sublime下 ctrl+shift+P打开package control面板 输入pci进入安装插件列表 输入Terminal找到插件安装 配置sublimeServer sublime下 ctrl+shift+P打开package control面板 输入sublimeServer进行安装","tags":[{"name":"sublime","slug":"sublime","permalink":"http://liufusong.github.io/tags/sublime/"}]},{"title":"es6属性基础教学，30分钟包会","date":"2017-04-21T14:51:15.000Z","path":"2017/04/21/es6属性基础教学，30分钟包会/","text":"摘要：看完此文包会es6，不会我吃翔ES6基础智商划重点在实际开发中，ES6已经非常普及了。掌握ES6的知识变成了一种必须。尽管我们在使用时仍然需要经过babel编译。 ES6彻底改变了前端的编码风格，可以说对于前端的影响非常巨大。值得高兴的是，如果你熟悉ES5，学习ES6并不需要花费太多的时间就可以掌握，因为常用的基础语法并不多，花少量的时间，就可以开始我们的ES6之旅了。 这篇文章不会详细的告诉你ES6的每一个细节知识，只会根据我自己的开发经验，将我在实际开发中常常用到的知识点分享给大家，给大家学习ES6一个方向的指引。这是因为考虑到很多同学虽然知道ES6的重要性，但是不知道自己需要掌握那些ES6的知识，也不知道这些知识需要掌握到什么程度，这给新手朋友带来了许多困惑，因此这篇文章就算是一个划重点吧，掌握这些，就可以轻轻松松得进行进一步学习了。 在学习之前，推荐大家使用babel官方提供的在线编译工具，编写自己的demo，会在右侧实时显示出编译之后的代码，以供参考学习 http://babeljs.io/repl/一、新的变量声明方式 let/const 与var不同，新的变量声明方式带来了一些不一样的特性，其中最重要的两个特性就是提供了块级作用域与不再具备变量提升。 通过2个简单的例子来说明这两点。 { let a = 20;} console.log(a); // a is not defined而这个简单的例子，会被编译为： { let _a = 20;} console.log(a); // a is not defined// ES5console.log(a); // undefinedvar a = 20; // ES6console.log(a); // a is not definedlet a = 20; 变量提升demo示例当然，你的代码编译成为了ES5之后，仍然会存在变量提升，因此这一点只需要我们记住即可。在实际使用中，也需要尽量避免使用变量提升的特性带来的负面影响。只有在面试题中，才会对变量提升不停的滥用。 使用ES6，我们需要全面使用let/const替换var，那么什么时候用let，什么时候用const就成为了一个大家要熟练区分的一个知识点。 我们常常使用let来声明一个值会被改变的变量，而使用const来声明一个值不会被改变的变量，也可以称之为常量。 当值为基础数据类型时，那么这里的值，就是指值本身。而当值对应的为引用数据类型时，那么我这里说的值，则表示指向该对象的引用。这里需要注意，正因为该值为一个引用，只需要保证引用不变就可以，我们仍然可以改变该引用所指向的对象。 当我们试图改变const声明的变量时，则会报错。 写几个例子，大家可以仔细揣摩一下： let a = null;a = 20;const obDev = { a: 20, b: 30} obDev.a = 30; console.log(obDev); // Object {a: 30, b: 30}const fn = function() {}const a = obDev.a;… …只要抓住上面我说的特性，那么在使用let/const时就会显得游刃有余。根据我自己的经验，使用const的场景要比使用let的场景多很多。 二、 箭头函数的使用 之前我说ES6颠覆了js的编码习惯，箭头函数的使用占了很大一部分。 首先是写法上的不同: // es5var fn = function(a, b) { return a + b;} // es6 箭头函数写法，当函数直接被return时，可以省略函数体的括号const fn = (a, b) =&gt; a + b; // es5var foo = function() { var a = 20； var b = 30; return a + b;} // es6const foo = () =&gt; { const a = 20; const b = 30; return a + b;}箭头函数可以替换函数表达式，但是不能替换函数声明其次还有一个至关重要的一点，那就是箭头函数中，没有this。如果你在箭头函数中使用了this，那么该this一定就是外层的this。 也正是因为箭头函数中没有this，因此我们也就无从谈起用call/apply/bind来改变this指向。记住这个特性，能让你在react组件之间传值时少走无数弯路。 var person = { name: ‘tom’, getName: function() { return this.name; }} // 我们试图用ES6的写法来重构上面的对象const person = { name: ‘tom’, getName: () =&gt; this.name} // 但是编译结果却是var person = { name: ‘tom’, getName: function getName() { return undefined.name; }};在ES6中，会默认采用严格模式，因此this也不会自动指向window对象了，而箭头函数本身并没有this，因此this就只能是undefined，这一点，在使用的时候，一定要慎重慎重再慎重，不然踩了坑你都不知道自己错在哪！这种情况，如果你还想用this，就不要用使用箭头函数的写法。// 可以稍做改动const person = { name: ‘tom’, getName: function() { return setTimeout(() =&gt; this.name, 1000); }} // 编译之后变成var person = { name: ‘tom’, getName: function getName() { var _this = this; // 使用了我们在es5时常用的方式保存this引用 return setTimeout(function () { return _this.name; }, 1000); } };先记住箭头函数的写法，并留意箭头函数中关于this的特殊性，更过实践与注意事项我们在封装react组件时再慢慢来感受。 三、模板字符串 模板字符串是为了解决使用+号拼接字符串的不便利而出现的。它的功能非常强大，但是我们大多数时候使用它则非常简单。看一个例子大家就明白怎么使用了。 // es6const a = 20;const b = 30;const string = ${a}+${b}=${a+b}; // es5var a = 20;var b = 30;var string = a + “+” + b + “=” + (a + b);使用 `` 将整个字符串包裹起来，而在其中使用 ${} 来包裹一个变量或者一个表达式。 当然模板字符串还支持换行等强大的功能，更多的大家可通过参考资料进一步学习。 四、 解析结构 解析结构是一种全新的写法，我们只需要使用一个例子，大家就能够明白解析结构到底是怎么一回事儿。 // 首先有这么一个对象const props = { className: ‘tiger-button’, loading: false, clicked: true, disabled: ‘disabled’}当我们想要取得其中的2个值：loading与clicked时： // es5var loading = props.loading;var clicked = props.clicked; // es6const { loading, clicked } = props; // 给一个默认值，当props对象中找不到loading时，loading就等于该默认值const { loading = false, clicked } = props;是不是简单了许多？正是由于解析结构大大减少了代码量，因此它大受欢迎，在很多代码中它的影子随处可见。 // 比如// section1import React, { Component } from ‘react’; // section2export { default } from ‘./Button’; // section3const { click, loading } = this.props;const { isCheck } = this.state; // more 任何获取对象属性值的场景都可以使用解析结构来减少我们的代码量另外，数组也有属于自己的解析结构。 // es6const arr = [1, 2, 3];const [a, b, c] = arr; // es5var arr = [1, 2, 3];var a = arr[0];var b = arr[1];var c = arr[2];数组以序列号一一对应，这是一个有序的对应关系。而对象根据属性名一一对应，这是一个无序的对应关系。根据这个特性，使用解析结构从对象中获取属性值更加具有可用性。 五、 函数默认参数 之前我们不能直接为函数指定默认参数，因此很多时候为了保证传入的参数具备一个默认值，我们常常使用如下的方法： function add(x, y) { var x = x || 20; var y = y || 30; return x + y;} console.log(add()); // 50这种方式并不是没有缺点，比如当我传入一个x值为false，这个时候任然会取到默认值，就不是我们的本意了。来看看ES6的默认值写法： function add(x = 20, y = 30) { return x + y;} console.log(add());在实际开发中给参数添加适当的默认值，可以让我们对函数的参数类型有一个直观的认知。 const ButtonGroupProps = { size: ‘normal’, className: ‘xxxx-button-group’, borderColor: ‘#333’} export default function ButtonGroup(props = ButtonGroupProps) { … …}六、 展开运算符 在ES6中用…来表示展开运算符，它可以将数组方法或者对象进行展开。先来看一个例子它是如何使用的。 const arr1 = [1, 2, 3];const arr2 = […arr1, 10, 20, 30]; // 这样，arr2 就变成了[1, 2, 3, 10, 20, 30];当然，展开对象数据也是可以得到类似的结果 const obj1 = { a: 1, b: 2, c: 3} const obj2 = { …obj1, d: 4, e: 5, f: 6} // 结果类似于 const obj2 = Object.assign({}, obj1, {d: 4})展开运算符还常常运用在解析结构之中，例如我们在Raect封装组件的时候常常不确定props到底还有多少数据会传进来，就会利用展开运算符来处理剩余的数据。 // 这种方式在react中十分常用const props = { size: 1, src: ‘xxxx’, mode: ‘si’} const { size, …others } = props; console.log(others) // 然后再利用暂开运算符传递给下一个元素，再以后封装react组件时会大量使用到这种方式，正在学习react的同学一定要搞懂这种使用方式 展开运算符还用在函数的参数中，来表示函数的不定参。只有放在最后才能作为函数的不定参，否则会报错。 // 所有参数之和const add = (a, b, …more) =&gt; { return more.reduce((m, n) =&gt; m + n) + a + b} console.log(add(1, 23, 1, 2, 3, 4, 5)) // 39展开运算符的运用可以大大提高我们的代码效率，但是在刚开始使用的时候比较绕脑，掌握好了用起来还是非常爽的，记住这些使用场景，平时在用的时候可以刻意多运用就行了。 七、对象字面量 与 class ES6针对对象字面量做了许多简化语法的处理。 当属性与值的变量同名时。const name = ‘Jane’;const age = 20 // es6const person = { name, age} // es5var person = { name: name, age: age};那么这种方式在任何地方都可以使用，比如在一个模块对外提供接口时 const getName = () =&gt; person.name;const getAge = () =&gt; person.age; // commonJS的方式module.exports = { getName, getAge } // ES6 modules的方式export default { getName, getAge }除了属性之外，对象字面量写法中的方法也可以有简写方式。// es6const person = { name, age, getName() { // 只要不使用箭头函数，this就还是我们熟悉的this return this.name }} // es5var person = { name: name, age: age, getName: function getName() { return this.name; }};在对象字面量中可以使用中括号作为属性，表示属性也能是一个变量了。const name = ‘Jane’;const age = 20 const person = { }在ant-design的源码实现中，就大量使用了这种方式来拼接当前元素的className，例如: let alertCls = classNames(prefixCls, { [`${prefixCls}-${type}`]: true, [`${prefixCls}-close`]: !this.state.closing, [`${prefixCls}-with-description`]: !!description, [`${prefixCls}-no-icon`]: !showIcon, [`${prefixCls}-banner`]: !!banner, }, className);ant-design是一个认可度非常高的UI组件库，官方使用react的方式进行了实现，除此之外，还有vue也有对应的实现，有兴趣的同学可以去他们的官网了解学习。https://ant.design/index-cnclassES6为我们创建对象提供了新的语法糖，这就是Class语法。如果你对ES5中面向对象的方式比较熟悉的话，Class掌握起来也是非常迅速的，因为除了写法的不同，它并不会增加新的难以理解的知识点。我们先利用一个简单的例子来看看写法的不同。 // ES5// 构造函数function Person(name, age) { this.name = name; this.age = age;} // 原型方法Person.prototype.getName = function() { return this.name} // ES6class Person { constructor(name, age) { // 构造函数 this.name = name; this.age = age; } getName() { // 原型方法 return this.name }}babel会将ES6的写法编译成为利用Object.defineProperty实现的方式，这个方法的具体用处大家可以在《JavaScript高级编程3》中学习了解，包括get，set，等都有详细的说明除此之外，我们还需要特别注意在实际使用中的几种写法方式的不同，在下面的例子注释中，我说明了他们分别对应的ES5中的含义。 class Person { constructor(name, age) { // 构造函数 this.name = name; this.age = age; } getName() { // 这种写法表示将方法添加到原型中 return this.name } static a = 20; // 等同于 Person.a = 20 c = 20; // 表示在构造函数中添加属性 在构造函数中等同于 this.c = 20 // 箭头函数的写法表示在构造函数中添加方法，在构造函数中等同于this.getAge = function() {} getAge = () =&gt; this.age }箭头函数需要注意的仍然是this的指向问题，因为箭头函数this指向不能被改变的特性，因此在react组件中常常利用这个特性来在不同的组件进行传值会更加方便。 继承 extends相比ES5，ES6的继承就要简单很多，我们直接来看一个例子。 class Person { constructor(name, age) { this.name = name; this.age = age; } getName() { return this.name }} // Student类继承Person类class Student extends Person { constructor(name, age, gender, classes) { super(name, age); this.gender = gender; this.classes = classes; } getGender() { return this.gender; }}我们只需要一个extends关键字，就可以实现继承了，不用像ES5那样去担心构造函数继承和原型继承，除此之外，我们还需要关注一个叫做super的方法。 在继承的构造函数中，我们必须如上面的例子那么调用一次super方法，它表示构造函数的继承，与ES5中利用call/apply继承构造函数是一样的功能。 // 构造函数中// es6super(name, age); // es5Person.call(this);super还可以直接调用父级的原型方法，super.getName，但是我自己从来没这样用过，也就不扩展说了。继承在react中有大量的使用场景，许多组件都利用继承来创建。 import React, { Component } from ‘react’; class App extends Component { defaultProps = {} state = {} componentWillMount() {} componentDidMount() {} btnClick = e =&gt; {} render() {}}只要根据我们上面所学到的知识，明确的知道哪些属性方法是放在构造函数中，哪些属性方法是放到了原型中，那么我们自己在编写react组件的时候就要简单和清晰很多。 其实只要我们ES5面向对象的知识足够扎实，ES6和react掌握起来也没有太多的难度，所有的学习难点，并不在ES6这些不同的语法糖上，而在于ES5中的原理，因此我在前面分享ES5的核心知识的时候，很多读者老爷都迫不及待的希望我能够更多的说一说ES6的知识。其实我们都没有必要那么着急，只要前面10多篇文章的知识足够扎实，这篇文章所涉及到的常用的ES6知识，最多花30分钟也就掌握了。这些写法上的不同并不会造成大家理解上的困难，只需要有一个熟悉过程就行了。所以大家的重点，还是要回归到基础上来。","tags":[{"name":"es6","slug":"es6","permalink":"http://liufusong.github.io/tags/es6/"},{"name":"js","slug":"js","permalink":"http://liufusong.github.io/tags/js/"}]},{"title":"node安装报错解决问题","date":"2017-04-20T09:37:59.000Z","path":"2017/04/20/node安装报错解决问题/","text":"摘要：node安装失败报错 这是msi安装提示报错的范例。 导致这种问题的原因一般有两个： 一个可能是原来安装过Node.js不过没有卸载干净 另一个可能就是msi安装包的权限问题。 *首先检查你的电脑是否已经完全卸载了node.js。 cmd里键入“node -v” 然后去环境变量Path里看看还有没有nodejs的记录。 *如果都没有，那么就应该属于权限问题了。 首先以管理员身份打开cmd，并把cmd目录跳转到你 node.js的msi安装包的根目录，像这样： 然后，利用cmd运行你的msi安装包。 msiexec /package命令 像这样。 一般就可以顺利安装了。 *通常导致2502和2503的报错就是这两个问题。","tags":[{"name":"node","slug":"node","permalink":"http://liufusong.github.io/tags/node/"}]},{"title":"js动态计算移动端rem适配问题","date":"2017-04-20T06:33:37.000Z","path":"2017/04/20/js动态计算移动端rem适配问题/","text":"摘要：css3和js是实现rem适配 第一：css3的media query来实现适配，例如下面这样：12345678910111213141516171819202122232425262728html &#123;font-size : 20px;&#125;@media only screen and (min-width: 401px)&#123;html &#123;font-size: 25px !important;&#125;&#125;@media only screen and (min-width: 428px)&#123;html &#123;font-size: 26.75px !important;&#125;&#125;@media only screen and (min-width: 481px)&#123;html &#123;font-size: 30px !important;&#125;&#125;@media only screen and (min-width: 569px)&#123;html &#123;font-size: 35px !important;&#125;&#125;@media only screen and (min-width: 641px)&#123;html &#123;font-size: 40px !important;&#125;&#125; 第二通过js动态设置html字体，例如下面这样123456789101112131415161718(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; // 默认设计图为640的情况下1rem=100px；根据自己需求修改 if(clientWidth&gt;=640)&#123; docEl.style.fontSize = &apos;100px&apos;; &#125;else&#123; docEl.style.fontSize = 100 * (clientWidth / 640) + &apos;px&apos;; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);&#125;)(document, window); 以上两种方式均能实现rem适配","tags":[{"name":"js","slug":"js","permalink":"http://liufusong.github.io/tags/js/"},{"name":"rem","slug":"rem","permalink":"http://liufusong.github.io/tags/rem/"},{"name":"css3","slug":"css3","permalink":"http://liufusong.github.io/tags/css3/"},{"name":"media query","slug":"media-query","permalink":"http://liufusong.github.io/tags/media-query/"}]},{"title":"倒计时功能","date":"2017-04-19T05:08:08.000Z","path":"2017/04/19/倒计时功能/","text":"摘要： 倒计时功能 话不多说直接代码123456789101112131415161718192021window.onload = function()&#123; showtime() function showtime()&#123; var www = document.getElementById(&apos;www&apos;);//页面需要有一个id展示倒计时 var Newtime = new Date();// 获取当前时间 var endtime = new Date(&apos;2015/12/11,14:44:00&apos;); // 设置结束时间 var lefttime=parseInt((endtime.getTime()-Newtime.getTime())/1000); //获取差值 if(lefttime&gt;0)&#123; var date = parseInt(lefttime/(60*60*24)); //转化为天 var hours = parseInt(lefttime/(60*60)%24);//转化为小时 var minute= parseInt(lefttime/60%60);//转化为分钟 var second= parseInt(lefttime%60); //转化为秒 www.innerHTML = date+&apos;日&apos;+hours+&apos;:&apos;+minute+&apos;:&apos;+second //展示 setTimeout(showtime,1000) &#125;else&#123; //倒计时归零 www.innerHTML = 00+&apos;日&apos;+0+&apos;:&apos;+0+&apos;:&apos;+0 &#125; &#125;&#125;","tags":[{"name":"倒计时","slug":"倒计时","permalink":"http://liufusong.github.io/tags/倒计时/"}]},{"title":"前端技术链接","date":"2017-04-17T06:54:20.000Z","path":"2017/04/17/前端技术链接/","text":"摘要: 前端技术链接 swiper移动端触摸滑动插件Framework7前端框架，是开发人员可以基于 web 技术构建 IOS7 程序css3loading动画图片懒加载SWEETALERT2-强大的纯JS模态消息对话框插件网站炫酷效果Node.js v6.10.2 文档MDN提供有关开放网络技术(Open Web)的信息前端笔记网","tags":[{"name":"链接","slug":"链接","permalink":"http://liufusong.github.io/tags/链接/"},{"name":"前端","slug":"前端","permalink":"http://liufusong.github.io/tags/前端/"}]},{"title":"hexo+github创建属于自己的博客","date":"2017-04-14T06:05:59.000Z","path":"2017/04/14/hexo-github创建属于自己的博客/","text":"摘要： hexo+github创建博客学不会就去吃翔 直接上实用的不罗嗦 配置环境安装Node（必须） 作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须） 作用：把本地的hexo内容提交到github上去. 安装Xcode就自带有Git，我就不多说了。 申请GitHub（必须） 作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。 正式安装HexoNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。 执行如下命令安装Hexo：1sudo npm install -g hexo 初始化然后，执行init命令初始化hexo,命令：1hexo init 好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。 生成静态页面1hexo generate（hexo g也可以） 本地启动 启动本地服务，进行文章预览调试，命令：1hexo server 浏览器输入http://localhost:4000 我不知道你们能不能，反正我不能，因为我还有环境没配置好 配置Github建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： vim _config.yml 翻到最下面，改成我这样子的 deploy: type: git repo: https://github.com/leopardpan/leopardpan.github.io.git branch: master 然后执行命令： npm install hexo-deployer-git --save 网上会有很多说法，有的type是github, 还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。 忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。 然后，执行配置命令： hexo deploy 然后再浏览器中输入https://liufusong.github.io/就行了，我的github的账户叫liufusong,把这个改成你github的账户名就行了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate hexo deploy 一些常用命令： hexo new&quot;postName&quot; #新建文章 hexo new page&quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 报错总结 ERROR Deployer not found: git 或者 ERROR Deployer not found: github 解决方法： npm install hexo-deployer-git –save 如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令： rm-rf.DS_Store ERROR Plugin load failed: hexo-server 原因： Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore. 解决方法，执行命令： sudo npm install hexo-server 执行命令hexo server，提示：Usage: hexo …. 原因： 我认为是没有生成本地服务 解决方法，执行命令： npm install hexo-server --save 提示：hexo-server@0.1.2 node_modules/hexo-server …. 表示成功了 这个时候再执行： hexo-server 得到: I NFOHexois running at http://0.0.0.0:4000/.PressCtrl+C to stop. 这个时候再点击http://0.0.0.0:4000，正常情况下应该是最原始的画面，但是我看到的是： 白板和Cannot GET / 几个字 原因： 由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令： npm install hexo-renderer-ejs --save npm install hexo-renderer-stylus --save npm install hexo-renderer-marked --save 这个时候再重新生成静态文件，命令： hexo generate（或hexo g） 启动本地服务器： hexo server（或hexo s） 再，点击http://0.0.0.0:4000,OK终于可以看到属于你自己的blog啦，😄，虽然很简陋，但好歹有了一个属于自己的小窝了，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://liufusong.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://liufusong.github.io/tags/github/"}]},{"title":"angular工作中最常用的几种功能","date":"2017-04-12T13:54:19.000Z","path":"2017/04/12/angular工作中最常用的几种功能/","text":"摘要： AngularJS 最常用的功能 第一 迭代输出之ng-repeat标签 ng-repeat让table ul ol等标签和js里的数组完美结合 12345&lt;ul&gt; &lt;li ng-repeat=&quot;person in persons&quot;&gt; &#123; &#123; person.name &#125; &#125; is &#123; &#123;person.age&#125; &#125; years old. &lt;/li&gt;&lt;/ul&gt; 你甚至可以指定输出的顺序： 1&lt;li ng-repeat=&quot;person in persons | orderBy:&apos;name&apos;&quot;&gt; 第二 动态绑定之ng-model标签 任何有用户输入，只要是有值的html标签，都可以动态绑定js中的变量，而且是动态绑定。 1&lt;input type=&quot;text&quot; ng-model=&apos;password&apos;&gt; 对于绑定的变量，你可以使用{ { } } 直接引用 1&lt;span&gt;you input password is &#123;&#123;password&#125;&#125;&lt;/span&gt; 如果你熟悉fiter，你可以很容易的按你的需要格式输出 1&lt;span&gt;&#123; &#123; 1288323623006 | date:&apos;yyyy-MM-dd HH:mm:ss Z&apos; &#125; &#125; &lt;/span&gt; 第三 绑定点击事件之ng-click事件 使用ng-click你可以很容易的为一个标签绑定点击事件。 1&lt;button ng-click=&quot;pressMe()&quot;/&gt; 当然前提是你要在$scope域中定义的自己的pressMe方法。 和传统的onclick方法不同，你甚至可以为ng-click方法传递一个对象，就像这样： 12345&lt;ul&gt; &lt;li ng-repeat=&quot;person in persons&quot;&gt; &lt;button ng-click=&quot;printf(person)&quot;/&gt; &lt;/li&gt;&lt;/ul&gt; 当然还有ng-dblclick标签 第四 分支语句之ng-switch on、ng-if/ng-show/ng-hide/ng-disabled标签 分支语句让你在界面上都可以写逻辑判断。12345678910111213&lt;ul&gt; &lt;li ng-repeat=&quot;person in persons&quot;&gt; &lt;span ng-switch on=&quot;person.sex&quot;&gt; &lt;span ng-switch-when=&quot;1&quot;&gt;you are a boy&lt;/span&gt; &lt;span ng-switch-when=&quot;2&quot;&gt;you are a girl&lt;/span&gt; &lt;/span&gt; &lt;span ng-if=&quot;person.sex==1&quot;&gt;you may be a father&lt;/span&gt; &lt;span ng-show=&quot;person.sex==2&quot;&gt;you may be a mother&lt;/span&gt; &lt;span&gt; please input your baby&apos;s name:&lt;input type=&quot;text&quot; ng-disabled=&quot;!person.hasBaby&quot;/&gt; &lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; 第五 校验语法之ng-trim ng-minlength ng-maxlength required ng-pattern 等标签 表单中的输入框，你可以使用上面的标签来实现对用户输入的校验。 从字面意思上你已经知道了它们的意思。 123&lt;form name=&quot;yourForm&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;inputText&quot; required ng-trim=&quot;true&quot; ng-model=&quot;userNum&quot; ng-pattern=&quot;/^[0-9]*[1-9][0-9]*$/&quot; ng-maxlength=&quot;6&quot; maxlength=&quot;6&quot;/&gt;&lt;/form&gt; 你可以通过 $scope.yourForm.inputText.$error.required 来判断输入框是否为空 你可以通过 $scope.yourForm.inputText.$invalid 来判断输入的内容是否满足ng-pattern，ng-maxlength，maxlength 你通过$scope.userNum获得的输入内容是去掉前后空白的，因为ng-trim的存在。第六 下拉框之ng-options标签 ng-options是为下拉框专门打造的标签。 1&lt;select ng-model=&quot;yourSelected&quot; ng-options=&quot;person.id as person.name in persons&quot;&gt;&lt;/select&gt; 下拉框中显示的是person.name，当你选中其中一个的时候，你可以通过yourSelected得到你选中的person.id. 第七 控制css之ng-style标签 ng-style帮你轻松控制你的css属性 1&lt;span ng-style=&quot;myColor&quot;&gt;your color&lt;/span&gt; 你可以通过给myColor赋值的形式来改变你想要的效果，就像这样： 12$scope.myColor= &#123; color:&apos;blue&apos; &#125; ;$scope.myColor=&#123;cursor: &apos;pointer&apos;,color:&apos;blue&apos;&#125;; 第八 异步请求之$http对象。 AngularJS 提供了一个类似jquery的$.ajax的对象，用于异步请求。 在AngularJS中对异步操作是推崇至极的，所以$http的操作都是异步的不像jquery.ajax里还提供了async参数。 1234567$http(&#123;method : &apos;POST&apos;,params : &#123; id:123&#125;, data:&#123;name:&apos;john&apos;,age:27&#125;, url : &quot;/mypath&quot;&#125;).success(function(response, status, headers, config)&#123;//do anything what you want;&#125;).error(function(response, status, headers, config)&#123;//do anything what you want;&#125;); 如果你是POST请求，params里的数据会帮你拼到url后面，data里的数据会放到请求体中。","tags":[{"name":"angular","slug":"angular","permalink":"http://liufusong.github.io/tags/angular/"}]},{"title":"正则表达式","date":"2017-04-11T09:22:25.000Z","path":"2017/04/11/正则表达式/","text":"摘要: 正则表达式的基本使用 本文目标 让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。如何使用本教程 别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？正则表达式到底是什么东西？ 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。很可能你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。入门 学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。 假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。 这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。 不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。 \\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。 假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.*\\bLucy\\b。 这里，.是另一个元字符，匹配除了换行符以外的任意字符。同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。 0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。 这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。 为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。 元字符 现在你已经知道几个很有用的元字符了，如\\b,.,*，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。 下面来看看更多的例子：\\ba\\w\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w)，最后是单词结束处(\\b)。 \\d+匹配1个或更多连续的数字。这里的+是和类似的元字符，不同的是匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\\b\\w{6}\\b 匹配刚好6个字符的单词。表1.常用的元字符代码 说明. 匹配除换行符以外的任意字符\\w 匹配字母或数字或下划线或汉字\\s 匹配任意的空白符\\d 匹配数字\\b 匹配单词的开始或结束^ 匹配字符串的开始$ 匹配字符串的结束 元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。 字符转义 如果你想查找元字符本身的话，比如你查找.,或者,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和\\。当然，要查找\\本身，你也得用\\.例如：deerchao\\.net匹配deerchao.net，C:\\\\Windows匹配C:\\Windows。重复 你已经看过了前面的,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如,{5,12}等)：表2.常用的限定符代码/语法 说明 重复零次或更多次 重复一次或更多次? 重复零次或一次{n} 重复n次{n,} 重复n次或更多次{n,m} 重复n到m次下面是一些使用重复的例子：Windows\\d+匹配Windows后面跟1个或更多数字^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)字符类 要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。下面是一个更复杂的表达式：(?0\\d{2}[) -]?\\d{8}。 这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或 - 或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。分枝条件 不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。(?0\\d{2})?[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\\d{5}-\\d{4}|\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。分组 我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。(\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。 不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。理解这个表达式的关键是理解2[0-4]\\d|25[0-5]|[01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。反义 有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：表3.常用的反义代码代码/语法 说明\\W 匹配任意不是字母，数字，下划线，汉字的字符\\S 匹配任意不是空白符的字符\\D 匹配任意非数字的字符\\B 匹配不是单词开头或结束的位置[^x] 匹配除了x以外的任意字符[^aeiou] 匹配除了aeiou这几个字母以外的任意字符例子：\\S+匹配不包含空白符的字符串。]+&gt;匹配用尖括号括起来的以a开头的字符串。##","tags":[{"name":"正则","slug":"正则","permalink":"http://liufusong.github.io/tags/正则/"}]},{"title":"KonvaJS中文文档","date":"2017-04-08T12:14:54.000Z","path":"2017/04/08/KonvaJS中文文档/","text":"摘要: Konva 是一个 基于 Canvas 开发的 2d js 框架库, 它可以轻松的实现桌面应用和移动应用中的图形交互交互效果正文: KonvaJS Konva 是一个 基于 Canvas 开发的 2d js 框架库, 它可以轻松的实现桌面应用和移动应用中的图形交互交互效果. Konva 可以高效的实现动画, 变换, 节点嵌套, 局部操作, 滤镜, 缓存, 事件等功能, 不仅仅适用于桌面与移动开发, 还有更为广泛的应用. Konva 允许在舞台上绘图, 添加事件监听, 移动或缩放某个图形, 独立旋转, 以及高效的动画. 即使应用中含有数千个图形也是可以轻松实现的. 1.1. 使用 Konva 打开链接 http://konvajs.github.io/, 下载 KonvaJS 代码. 开发中为了方便调试, 使用完全版. 实际使用使用压缩版. 使用 script 标签导入需要使用的 Konva 库. &lt;script src=&quot;konva.js&quot;&gt;&lt;/script&gt; 1.2. KonvaJS 的理念 任何图形都存在于舞台中( Konva.Stage ). 这个舞台中又可以包多个用户层( Konva.Layer ). 每一个层中都含有两个 canvas 着色器: 一个前台渲染器, 一个后台渲染器. 前台渲染器是可以看见的部分,而后台渲染器是一个隐藏的 canvas. 后台渲染器为了提高效率实现事件监听的工作. 每一个层可以包含形状( Shape ), 形状的组( Group ), 甚至是由组组成的组. 舞台, 层, 组, 以及形状都是虚拟的节点( node ). 类似于 HTML 页面中的 DOM 节点. 在这个图形中, 首先有一个舞台( Stage ). 该舞台在页面中与整个页面的大小一样. 然后舞台中有一个层( Layer ). 层中有一个矩形( Rect )和一个圆形( Circle ). 因此就有一个树结构:所有的节点都可以设置样式与变化. 即使 Konva 可以重新渲染形状, 例如: 矩形, 圆形, 图片, 精灵, 文本, 线段, 多边形, 正多边形, 路径, 和星星等. 但是开发者依旧可以根据 Shape 类的模板自定义自己的图形, 然后重写 draw 方法.只要拥有了 舞台( Stage ), 并且上面放置了层( Layer )和图形( Shape ), 那么就可以为他添加事件监听, 变换节点, 运行动画, 使用路径, 甚至是更多的效果.###例如要实现上面的案例: 需要引入 Konva.js 文件&lt;script src=&quot;konva.js&quot;&gt;&lt;/script&gt; 然后页面中放置一个容器作为 Konva 处理的对象. Konva 会在该容器中添加 canvas 标签. 值得说明的是, 需要为这个标签添加 id 属性.&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt; 然后编写 js 代码. Konva 是一个完全面向对象的库.创建舞台var stage = new Konva.Stage({ container: &apos;dv&apos;, width: window.innerWidth, height: window.innerHeight }); 首先, 在 Konva 中所有的图形都是在 Konva 中的一个构造函数. Konva 是全局的命名空间.创建舞台使用的是 Stage 构造函数. 该函数需要提供参数.Konva 中所有图形的参数都是使用 json 对象的方式进行提供.舞台需要设置容器的 id, 即 container 属性. 以及宽( width ), 高( height ).舞台中可以放置一个到多个层( Layer ), 所有的图形应该放在在层中.首先创建层对象. 层对象不需要传递参数.var layer = new Konva.Layer();将层添加到舞台中. Konva 中凡是添加, 都是使用 add 方法.stage.add( layer );在层中放置一个矩形, 就创建一个 矩形对象.矩形对象需要四个参数来确定, 分别是 左上角的两个坐标, 和 宽与高.var rect = new Konva.Rect({x: 100,y: 50,width: 200,height: 100,fill: ‘red’});Konva 中添加颜色使用 fill 属性和 stroke 属性, 分别表示填充颜色与描边颜色.将矩形添加到 层中layer.add( rect );在层中添加一个圆形, 使用构造函数 Circlevar circle = new Konva.Circle({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: 100,fill: ‘pink’,stroke: ‘blue’});layer.add( circle );Konva 中使用 radius 设置圆形的半径.Konva 中如果需要获取对象的数据, 使用 getXXX 方法. 传入参数即设置, 不传参数就是获取数据.最后绘图使用 draw 方法layer.draw();1.3. 基本形状 Konva.js 支持的形状有: 矩形( Rect ), 圆形( Circle ), 椭圆( Rllipse ), 线段( Line ), 图像( Image ), 文本( Text ), 文本路径( TextPath ), 星星( Start ), 标签( Label ), SVG 路径( SVG Path ), 正多边形( RegularPolygon ). 同时也可以自定义形状. 自定义形状使用 Shape 构造函数创建需要提供自定义的绘图方法 sceneFuncvar triangle = new Konva.Shape({sceneFunc: function ( ctx ) {// 自定义绘图路径ctx.moveTo( window.innerWidth / 2, window.innerHeight / 4 );ctx.lineTo( window.innerWidth / 2 - window.innerHeight / ( 2 1.732 ), window.innerHeight 3 / 4 );ctx.lineTo( window.innerWidth / 2 + window.innerHeight / ( 2 1.732 ), window.innerHeight 3 / 4 );ctx.closePath();// Konva.js 的独有方法ctx.fillStrokeShape( this );},fill: ‘pink’,stroke: ‘red’});将图形添加后绘图layer.add( triangle );layer.draw(); 1.4. 样式 所有的形状都支持下列样式属性: 填充. 颜色, 渐变或图片.描边. 颜色与宽度.阴影. 颜色, 偏移量, 透明度与模糊透明度1.4.1. 绘制正五边形 构造函数: Konva.RegularPolygon( options ) 常用属性: x, y. 表示正多边形的中心坐标.sides. 表示正多边形的边数.radius. 表示半径.fill. 填充颜色.stroke. 描边的颜色.strokeWidth. 描边的宽度.shadowOffsetX 和 shadowOffsety. 描述背景的偏移量.shadowBlur. 表示模糊程度.opacity. 表示透明度( 取值在 0, 1 之间 ).案例 var shape = new Konva.RegularPolygon({x: stage.getWidth() / 2,y: stage.getHeight() / 2,sides: 5,radius: 70,fill: ‘red’,stroke: ‘black’,strokeWidth: 4,shadowOffsetX: 20,shadowOffsetY: 25,shadowBlurBlur: 40,opacity: 0.5});layer.add( shape ); 1.5. 事件 使用 Konva 可以轻松的实现监听用户添加的事件. 例如 click, dblclick, mouseover, tap, dbltap, touchstart 等. 属性值变化事件. 例如 scaleXChange, fillChange 等. 以及拖拽事件. 例如 dragstart, dragmove, dragend. 代码 circle.on( ‘mouseout touchend’, function () {console.log( ‘用户输入’ );});circle.on( ‘xChange’, function () {console.log( ‘位置发生改变’ );});circle.on( ‘dragend’, function () {console.log( ‘拖动停止’ );});1.6. 拖拽与降低 Konva 支持拖拽的功能. 也支持下降事件( drop, dropenter, dropleave, dropover ). 如果需要实现拖拽的功能. 可以设置 draggable 属性为 true. 创建的时候设置属性创建后使用方法设置属性shape.draggable( true );Konva 还支持给拖拽事件添加移动范围. 1.7. 滤镜( Filter ) Konva 支持多种滤镜功能. 例如: 模糊, 翻转, 声音等. 1.8. 动画 Konva 中可以使用两种方式创建动画 使用 Konva.Animationvar anim = new Konva.Animation(function ( frame ) {var time = frame.time,timeDiff = frame.timeDiff,frameRate = frame.frameRate;// 更新代码}, layer );使用 Konva.Tween var tween = new Konva.Tween({node: rect,duration: 1,x: 140,rotation: Math.PI * 2,opacity: 1,strokeWidth: 6}); // 或者使用新的短方法circle.to({duration: 1,fill: ‘green’});1.9. 选择器 当构建规模较大的应用时, 如果可以对元素进行搜索是非常方便的. Konva 使用选择器来实现元素的查找. 使用 find() 方法返回一个集合. 使用 findOne() 方法返回集合中的第 0 个元素. 给元素提供 name 属性, 可以使用 ‘.name’ 来进行获取. 类似于类选择器.使用构造函数的名字也可以作为名字选择器. 类似于标签选择器.使用 id 属性, 则使用 ‘#id’ 来获取.查找方法使用层对象来调用.案例 …var r = 100;var c1 = new Konva.Circle({x: stage.getWidth() / 8,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,id: ‘c1’});layer.add( c1 ); var c2 = new Konva.Circle({x: stage.getWidth() / 8 * 3,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,name: ‘c’});layer.add( c2 ); var c3 = new Konva.Circle({x: stage.getWidth() / 8 * 5,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,name: ‘c’});layer.add( c3 ); var c3 = new Konva.Circle({x: stage.getWidth() / 8 * 7,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’});layer.add( c3 ); layer.find( ‘.c’ ).each(function ( v, i ) {v.fill( ‘pink’ );}); layer.find( ‘#c1’ ).forEach(function ( v, i ) {v.stroke( ‘blue’ );v.strokeWidth( 10 );}); layer.find( ‘Circle’ ).each( function ( v, i ) {v.stroke( ‘green’ );});…1.10. 序列号与反序列化 所有被创建的对象都可以保存为 JSON 对象. 可以在服务器或本地存储中使用它. var json = stage.toJSON();同时, 也可以从 JSON 中恢复 Konva 对象. var json = ‘{“attrs”:{“width”:578,”height”:200},’ +‘“className”:”Stage”, ‘ +‘“children”:[{ ‘ +‘“attrs”:{},’ +‘“className”:”Layer”,’ +‘“children”:[ ‘ +‘{“attrs”:{ ‘ +‘“x”:100,”y”:100,’ +‘“sides”:6,”radius”:70,’ +‘“fill”:”red”,”stroke”:”black”,’ +‘“strokeWidth”:4},’ +‘“className”:”RegularPolygon”}’ +‘]’ +‘}]}’;var stage = Konva.Node.create(json, ‘container’); 形状 Shape2.1. 矩形 Rect 创建语法: new Konva.Rect( config ) 常用属性: cornerRadius 属性. 数字类型, 表示圆角矩形的圆角半径.fill 属性. 字符串, 设置填充颜色.stroke 属性. 字符串, 设置描边颜色.dash 属性. 数组, 用于描述虚线的间隔.x, y, width, height 属性. 数字, 描述矩形的位置与宽高.name, id 属性. 字符串, 用于设置搜索标记.opacity 属性. 数字, 用于设置透明度.scaleX, scaleY 属性. 数字, 用于设置缩放变换.rotation 属性. 数字, 用于设置旋转角度.draggable 属性. 布尔类型, 用于设置是否允许拖拽.lineJoin, lineCap 属性. 设置线样式.常用方法: Konva 中构造函数的属性多半有同名的方法.toJSON() 方法. 将动画转换成 json 字符串.to( params ) 方法. 使用 Tween 动画.setAttrs( config ) 与 setAttr( attr, val ) 方法, 用于重新设置属性.remove() 方法. 将当前对象删除, 但是销毁.on( evtStr, handler ) 与 off( evtStr ) 方法, 用于添加与移除事件.案例 …var rect = new Konva.Rect({x: 100, y: 100,width: 200, height: 100,stroke: ‘red’, fill: ‘pink’});layer.add( rect );…2.2. 圆 Circle 创建语法: new Konva.Circle( config ) 常用属性: radius 属性. 数字类型, 用于设置半径.fill, stroke 属性.strokeWidth 属性.lineJoin, lineCap 属性.dash 属性.x, y 属性常用方法: 2.3. 椭圆 Ellipse 创建语法: new Konva.Ellipse( config ). 常用属性: x, y 属性. 数字类型, 表示椭圆中心的坐标radius 属性. 对象类型, x, y 分别表示椭圆的长轴与短轴.案例 var ellipse = new Konva.Ellipse({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: {x: 100, y: 100},stroke: ‘red’,fill: ‘pink’,rotation: 30});效果 2.4. 楔形 Wedge 创建语法: new Konva.Wedge( config ) 常用属性: angle 属性. 表示楔形的角度. 角度带有方向, 水平向右为 0 度. 使用角度单位.radius 属性. 表示半径.clockwise 属性. 表示方向.x, y, lineJoin, lineCap, fill, stroke, …常用方法: 案例 …var data = [ .3, .4, .2, .1 ];var colors = ‘red, pink, green, blue’.split( ‘,’ );var startAngle = -90;data.forEach( function ( v, i ) {var wedge = new Konva.Wedge({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: 100,angle: startAngle + 360 * v,rotation: startAngle,fill: colors[ i ],opacity: .8}); startAngle += 360 * v;layer.add( wedge );});…效果 2.5. 线段 Line 线段有折现, 曲线与闭合线路的用法. 创建语法: new Konva.Line( config ) 常用属性: points 属性. 数组, 用于存储折线的各个点的坐标.tension 属性. 数字类型, 用于表示曲线连线. 默认为 0.closed 属性. 布尔值, 用于表示是否闭合路径.x, y 属性. 用于设置绘制直线时的参考坐标原点.常用方法: 说明: 使用 Konva.Line 构造函数创建直线.使用 Konva.Line 构造函数与 closed = true 属性可以创建多边形.使用 Konva.Line 构造函数与 tension 属性可以创建曲线板.使用 Konva.Line 构造函数与 tension 属性, 以及 closed = true 可以创建气泡.案例 var line = new Konva.Line({x: 100, y: 100,points: [ 10, 0, 100, 100, 200, 0 ],tension: 1,stroke: ‘red’});layer.add( line ); var rect = new Konva.Line({x: 300, y: 100,points: [ 0, 0, 100, 0, 100, 100, 0, 100 ],closed: true,stroke: ‘red’});layer.add( rect );效果 2.6. 图片 Image 创建语法: new Konva.Image( config ) 常用属性: x, y, width, heightimage 属性. 用于设置图片对象.crop 属性. 对象: { x, y, width, height }. 表示裁剪.2.7. 文本 Text 创建语法: new Konva.Text( config ) 常用属性: fontFamily 属性.fontSize 属性.fontStyle 属性.fontVariant 属性text 属性. 用于设置文本内容.align 属性. 可选值: left, center, right.padding 属性.lineHeight 属性.x, y 属性案例 // 创建文本var txt = new Konva.Text({x: 100, y: 100,align: ‘left’,text: ‘测试文本’,fontSize: 30,padding: 10,width: 200,height: 200 });layer.add( txt ); var rect = new Konva.Rect({x: 100, y: 100,width: 200, height: 200,stroke: ‘red’});layer.add( rect );效果 2.8. 星星 Star 创建语法: new Konva.Star( config ) 常用属性: x, ynumPoints 属性. 表示 几角星.innerRadius 属性. 表示内半径.outerRadius 属性. 表示外半径.旋转的五角星 var star = new Konva.Star({x: stage.getWidth() / 2,y: stage.getHeight() / 2,numPoints: 5,outerRadius: 100,innerRadius: 50,stroke: ‘red’,fill: ‘lightgreen’});layer.add( star ); var tween = new Konva.Tween({node: star,rotation: 360,duration: 2,onFinish: function () {this.reset();this.play();}});tween.play();效果 2.9. 圆环 Ring 创建语法: new Konva.Ring( config ) 常用属性: innerRadius, outerRadiusclockwise案例 var ring = new Konva.Ring({x: width / 2,y: height / 2,innerRadius: 50,outerRadius: 100,fill: ‘pink’,stroke: ‘blue’,});layer.add( ring );效果 2.10. 圆弧 Arc 创建语法: new Konva.Arc( config ) 常用属性: innerRadius, outerRadiusangle案例 var arc = new Konva.Arc({x: width / 2,y: height / 2,innerRadius: 70,outerRadius: 100,stroke: ‘green’,fill: ‘pink’,angle: 60,rotation: -90});layer.add( arc );效果 2.11. 正多边形 Regular Polygon 创建语法: new Konva.RegularPolygon( config ) 常用属性: sides 属性. 表示多边形的边数.radius 属性.案例 var shape = new Konva.RegularPolygon({x: width / 2, y: height / 2,sides: 6,radius: 100,fill: ‘pink’,stroke: ‘blue’});layer.add( shape );效果 2.12. 箭头 Arrow 创建语法: new Konva.Arrow( config ) 常用属性: points 属性tension 属性pointerLength 属性. 表示箭头的长度.pointerWidth 属性. 表示箭头的宽度.案例 var rect1 = new Konva.Rect({x: width / 4 - 50,y: height / 4 - 25,stroke: ‘#000’,width: 100,height: 50,fill: ‘pink’,opacity: .5});layer.add( rect1 ); var txt1 = new Konva.Text({x: width / 4 - 50,y: height / 4 - 6,fontSize: 12,text: ‘Object 构造函数’,align: ‘center’,width: 100,height: 50});layer.add( txt1 ); var rect2 = new Konva.Rect({x: width 3 / 4 - 50,y: height 3 / 4 - 25,stroke: ‘#000’,width: 100,height: 50,fill: ‘pink’,opacity: .5});layer.add( rect2 ); var txt2 = new Konva.Text({x: width 3 / 4 - 50,y: height 3 / 4 - 6,fontSize: 12,text: ‘Object.prototype’,align: ‘center’,width: 100,height: 50});layer.add( txt2 ); var arrow = new Konva.Arrow({points: [width / 4 + 50,height / 4, width / 2,height / 4, width / 2,height * 3 / 4, width 3 / 4 - 50 - 7,height 3 / 4],pointerLength: 15,pointerWidth: 6,fill: ‘#ccc’,stroke: ‘#ccc’,lineWidth: .7}); layer.add( arrow );效果 组 Group创建语法: new Konva.Group( config ) 常用属性: x, y, width, heightrotation, draggable案例 var group = new Konva.Group({x: 100, y: 100,width: 100,height: 100});layer.add( group );group.add( new Konva.Rect({x: 0, y: 0, width: 100, height: 100,fill: ‘red’, stroke: ‘blue’}) );注意: 放在 group 中的形状使用 group 作为参考坐标. KonvaJS Konva 是一个 基于 Canvas 开发的 2d js 框架库, 它可以轻松的实现桌面应用和移动应用中的图形交互交互效果. Konva 可以高效的实现动画, 变换, 节点嵌套, 局部操作, 滤镜, 缓存, 事件等功能, 不仅仅适用于桌面与移动开发, 还有更为广泛的应用. Konva 允许在舞台上绘图, 添加事件监听, 移动或缩放某个图形, 独立旋转, 以及高效的动画. 即使应用中含有数千个图形也是可以轻松实现的. 1.1. 使用 Konva 打开链接 http://konvajs.github.io/, 下载 KonvaJS 代码.开发中为了方便调试, 使用完全版. 实际使用使用压缩版.使用 script 标签导入需要使用的 Konva 库. 1.2. KonvaJS 的理念 任何图形都存在于舞台中( Konva.Stage ). 这个舞台中又可以包多个用户层( Konva.Layer ). 每一个层中都含有两个 着色器: 一个前台渲染器, 一个后台渲染器. 前台渲染器是可以看见的部分, 而后台渲染器是一个隐藏的 canvas. 后台渲染器为了提高效率实现事件监听的工作. 每一个层可以包含形状( Shape ), 形状的组( Group ), 甚至是由组组成的组. 舞台, 层, 组, 以及形状都是虚拟的节点( node ). 类似于 HTML 页面中的 DOM 节点. 在这个图形中, 首先有一个舞台( Stage ). 该舞台在页面中与整个页面的大小一样. 然后舞台中有一个层( Layer ). 层中有一个矩形( Rect )和一个圆形( Circle ). 因此就有一个树结构: 所有的节点都可以设置样式与变化. 即使 Konva 可以重新渲染形状, 例如: 矩形, 圆形, 图片, 精灵, 文本, 线段, 多边形, 正多边形, 路径, 和星星等. 但是开发者依旧可以根据 Shape 类的模板自定义自己的图形, 然后重写 draw 方法. 只要拥有了 舞台( Stage ), 并且上面放置了层( Layer )和图形( Shape ), 那么就可以为他添加事件监听, 变换节点, 运行动画, 使用路径, 甚至是更多的效果. 例如要实现上面的案例: 需要引入 Konva.js 文件 然后页面中放置一个容器作为 Konva 处理的对象. Konva 会在该容器中添加 canvas 标签. 值得说明的是, 需要为这个标签添加 id 属性. 然后编写 js 代码. Konva 是一个完全面向对象的库.创建舞台var stage = new Konva.Stage({container: ‘dv’,width: window.innerWidth,height: window.innerHeight});首先, 在 Konva 中所有的图形都是在 Konva 中的一个构造函数. Konva 是全局的命名空间.创建舞台使用的是 Stage 构造函数. 该函数需要提供参数.Konva 中所有图形的参数都是使用 json 对象的方式进行提供.舞台需要设置容器的 id, 即 container 属性. 以及宽( width ), 高( height ).舞台中可以放置一个到多个层( Layer ), 所有的图形应该放在在层中.首先创建层对象. 层对象不需要传递参数.var layer = new Konva.Layer();将层添加到舞台中. Konva 中凡是添加, 都是使用 add 方法.stage.add( layer );在层中放置一个矩形, 就创建一个 矩形对象.矩形对象需要四个参数来确定, 分别是 左上角的两个坐标, 和 宽与高.var rect = new Konva.Rect({x: 100,y: 50,width: 200,height: 100,fill: ‘red’});Konva 中添加颜色使用 fill 属性和 stroke 属性, 分别表示填充颜色与描边颜色.将矩形添加到 层中layer.add( rect );在层中添加一个圆形, 使用构造函数 Circlevar circle = new Konva.Circle({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: 100,fill: ‘pink’,stroke: ‘blue’});layer.add( circle );Konva 中使用 radius 设置圆形的半径.Konva 中如果需要获取对象的数据, 使用 getXXX 方法. 传入参数即设置, 不传参数就是获取数据.最后绘图使用 draw 方法layer.draw();1.3. 基本形状 Konva.js 支持的形状有: 矩形( Rect ), 圆形( Circle ), 椭圆( Rllipse ), 线段( Line ), 图像( Image ), 文本( Text ), 文本路径( TextPath ), 星星( Start ), 标签( Label ), SVG 路径( SVG Path ), 正多边形( RegularPolygon ). 同时也可以自定义形状. 自定义形状使用 Shape 构造函数创建需要提供自定义的绘图方法 sceneFuncvar triangle = new Konva.Shape({sceneFunc: function ( ctx ) {// 自定义绘图路径ctx.moveTo( window.innerWidth / 2, window.innerHeight / 4 );ctx.lineTo( window.innerWidth / 2 - window.innerHeight / ( 2 1.732 ), window.innerHeight 3 / 4 );ctx.lineTo( window.innerWidth / 2 + window.innerHeight / ( 2 1.732 ), window.innerHeight 3 / 4 );ctx.closePath();// Konva.js 的独有方法ctx.fillStrokeShape( this );},fill: ‘pink’,stroke: ‘red’});将图形添加后绘图layer.add( triangle );layer.draw(); 1.4. 样式 所有的形状都支持下列样式属性: 填充. 颜色, 渐变或图片.描边. 颜色与宽度.阴影. 颜色, 偏移量, 透明度与模糊透明度1.4.1. 绘制正五边形 构造函数: Konva.RegularPolygon( options ) 常用属性: x, y. 表示正多边形的中心坐标.sides. 表示正多边形的边数.radius. 表示半径.fill. 填充颜色.stroke. 描边的颜色.strokeWidth. 描边的宽度.shadowOffsetX 和 shadowOffsety. 描述背景的偏移量.shadowBlur. 表示模糊程度.opacity. 表示透明度( 取值在 0, 1 之间 ).案例 var shape = new Konva.RegularPolygon({x: stage.getWidth() / 2,y: stage.getHeight() / 2,sides: 5,radius: 70,fill: ‘red’,stroke: ‘black’,strokeWidth: 4,shadowOffsetX: 20,shadowOffsetY: 25,shadowBlurBlur: 40,opacity: 0.5});layer.add( shape ); 1.5. 事件 使用 Konva 可以轻松的实现监听用户添加的事件. 例如 click, dblclick, mouseover, tap, dbltap, touchstart 等. 属性值变化事件. 例如 scaleXChange, fillChange 等. 以及拖拽事件. 例如 dragstart, dragmove, dragend. 代码 circle.on( ‘mouseout touchend’, function () {console.log( ‘用户输入’ );});circle.on( ‘xChange’, function () {console.log( ‘位置发生改变’ );});circle.on( ‘dragend’, function () {console.log( ‘拖动停止’ );});1.6. 拖拽与降低 Konva 支持拖拽的功能. 也支持下降事件( drop, dropenter, dropleave, dropover ). 如果需要实现拖拽的功能. 可以设置 draggable 属性为 true. 创建的时候设置属性创建后使用方法设置属性shape.draggable( true );Konva 还支持给拖拽事件添加移动范围. 1.7. 滤镜( Filter ) Konva 支持多种滤镜功能. 例如: 模糊, 翻转, 声音等. 1.8. 动画 Konva 中可以使用两种方式创建动画 使用 Konva.Animationvar anim = new Konva.Animation(function ( frame ) {var time = frame.time,timeDiff = frame.timeDiff,frameRate = frame.frameRate;// 更新代码}, layer );使用 Konva.Tween var tween = new Konva.Tween({node: rect,duration: 1,x: 140,rotation: Math.PI * 2,opacity: 1,strokeWidth: 6}); // 或者使用新的短方法circle.to({duration: 1,fill: ‘green’});1.9. 选择器 当构建规模较大的应用时, 如果可以对元素进行搜索是非常方便的. Konva 使用选择器来实现元素的查找. 使用 find() 方法返回一个集合. 使用 findOne() 方法返回集合中的第 0 个元素. 给元素提供 name 属性, 可以使用 ‘.name’ 来进行获取. 类似于类选择器.使用构造函数的名字也可以作为名字选择器. 类似于标签选择器.使用 id 属性, 则使用 ‘#id’ 来获取.查找方法使用层对象来调用.案例 …var r = 100;var c1 = new Konva.Circle({x: stage.getWidth() / 8,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,id: ‘c1’});layer.add( c1 ); var c2 = new Konva.Circle({x: stage.getWidth() / 8 * 3,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,name: ‘c’});layer.add( c2 ); var c3 = new Konva.Circle({x: stage.getWidth() / 8 * 5,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,name: ‘c’});layer.add( c3 ); var c3 = new Konva.Circle({x: stage.getWidth() / 8 * 7,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’});layer.add( c3 ); layer.find( ‘.c’ ).each(function ( v, i ) {v.fill( ‘pink’ );}); layer.find( ‘#c1’ ).forEach(function ( v, i ) {v.stroke( ‘blue’ );v.strokeWidth( 10 );}); layer.find( ‘Circle’ ).each( function ( v, i ) {v.stroke( ‘green’ );});…1.10. 序列号与反序列化 所有被创建的对象都可以保存为 JSON 对象. 可以在服务器或本地存储中使用它. var json = stage.toJSON();同时, 也可以从 JSON 中恢复 Konva 对象. var json = ‘{“attrs”:{“width”:578,”height”:200},’ +‘“className”:”Stage”, ‘ +‘“children”:[{ ‘ +‘“attrs”:{},’ +‘“className”:”Layer”,’ +‘“children”:[ ‘ +‘{“attrs”:{ ‘ +‘“x”:100,”y”:100,’ +‘“sides”:6,”radius”:70,’ +‘“fill”:”red”,”stroke”:”black”,’ +‘“strokeWidth”:4},’ +‘“className”:”RegularPolygon”}’ +‘]’ +‘}]}’;var stage = Konva.Node.create(json, ‘container’); 形状 Shape2.1. 矩形 Rect 创建语法: new Konva.Rect( config ) 常用属性: cornerRadius 属性. 数字类型, 表示圆角矩形的圆角半径.fill 属性. 字符串, 设置填充颜色.stroke 属性. 字符串, 设置描边颜色.dash 属性. 数组, 用于描述虚线的间隔.x, y, width, height 属性. 数字, 描述矩形的位置与宽高.name, id 属性. 字符串, 用于设置搜索标记.opacity 属性. 数字, 用于设置透明度.scaleX, scaleY 属性. 数字, 用于设置缩放变换.rotation 属性. 数字, 用于设置旋转角度.draggable 属性. 布尔类型, 用于设置是否允许拖拽.lineJoin, lineCap 属性. 设置线样式.常用方法: Konva 中构造函数的属性多半有同名的方法.toJSON() 方法. 将动画转换成 json 字符串.to( params ) 方法. 使用 Tween 动画.setAttrs( config ) 与 setAttr( attr, val ) 方法, 用于重新设置属性.remove() 方法. 将当前对象删除, 但是销毁.on( evtStr, handler ) 与 off( evtStr ) 方法, 用于添加与移除事件.案例 …var rect = new Konva.Rect({x: 100, y: 100,width: 200, height: 100,stroke: ‘red’, fill: ‘pink’});layer.add( rect );…2.2. 圆 Circle 创建语法: new Konva.Circle( config ) 常用属性: radius 属性. 数字类型, 用于设置半径.fill, stroke 属性.strokeWidth 属性.lineJoin, lineCap 属性.dash 属性.x, y 属性常用方法: 2.3. 椭圆 Ellipse 创建语法: new Konva.Ellipse( config ). 常用属性: x, y 属性. 数字类型, 表示椭圆中心的坐标radius 属性. 对象类型, x, y 分别表示椭圆的长轴与短轴.案例 var ellipse = new Konva.Ellipse({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: {x: 100, y: 100},stroke: ‘red’,fill: ‘pink’,rotation: 30});效果 2.4. 楔形 Wedge 创建语法: new Konva.Wedge( config ) 常用属性: angle 属性. 表示楔形的角度. 角度带有方向, 水平向右为 0 度. 使用角度单位.radius 属性. 表示半径.clockwise 属性. 表示方向.x, y, lineJoin, lineCap, fill, stroke, …常用方法: 案例 …var data = [ .3, .4, .2, .1 ];var colors = ‘red, pink, green, blue’.split( ‘,’ );var startAngle = -90;data.forEach( function ( v, i ) {var wedge = new Konva.Wedge({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: 100,angle: startAngle + 360 * v,rotation: startAngle,fill: colors[ i ],opacity: .8}); startAngle += 360 * v;layer.add( wedge );});…效果 2.5. 线段 Line 线段有折现, 曲线与闭合线路的用法. 创建语法: new Konva.Line( config ) 常用属性: points 属性. 数组, 用于存储折线的各个点的坐标.tension 属性. 数字类型, 用于表示曲线连线. 默认为 0.closed 属性. 布尔值, 用于表示是否闭合路径.x, y 属性. 用于设置绘制直线时的参考坐标原点.常用方法: 说明: 使用 Konva.Line 构造函数创建直线.使用 Konva.Line 构造函数与 closed = true 属性可以创建多边形.使用 Konva.Line 构造函数与 tension 属性可以创建曲线板.使用 Konva.Line 构造函数与 tension 属性, 以及 closed = true 可以创建气泡.案例 var line = new Konva.Line({x: 100, y: 100,points: [ 10, 0, 100, 100, 200, 0 ],tension: 1,stroke: ‘red’});layer.add( line ); var rect = new Konva.Line({x: 300, y: 100,points: [ 0, 0, 100, 0, 100, 100, 0, 100 ],closed: true,stroke: ‘red’});layer.add( rect );效果 2.6. 图片 Image 创建语法: new Konva.Image( config ) 常用属性: x, y, width, heightimage 属性. 用于设置图片对象.crop 属性. 对象: { x, y, width, height }. 表示裁剪.2.7. 文本 Text 创建语法: new Konva.Text( config ) 常用属性: fontFamily 属性.fontSize 属性.fontStyle 属性.fontVariant 属性text 属性. 用于设置文本内容.align 属性. 可选值: left, center, right.padding 属性.lineHeight 属性.x, y 属性案例 // 创建文本var txt = new Konva.Text({x: 100, y: 100,align: ‘left’,text: ‘测试文本’,fontSize: 30,padding: 10,width: 200,height: 200 });layer.add( txt ); var rect = new Konva.Rect({x: 100, y: 100,width: 200, height: 200,stroke: ‘red’});layer.add( rect );效果 2.8. 星星 Star 创建语法: new Konva.Star( config ) 常用属性: x, ynumPoints 属性. 表示 几角星.innerRadius 属性. 表示内半径.outerRadius 属性. 表示外半径.旋转的五角星 var star = new Konva.Star({x: stage.getWidth() / 2,y: stage.getHeight() / 2,numPoints: 5,outerRadius: 100,innerRadius: 50,stroke: ‘red’,fill: ‘lightgreen’});layer.add( star ); var tween = new Konva.Tween({node: star,rotation: 360,duration: 2,onFinish: function () {this.reset();this.play();}});tween.play();效果 2.9. 圆环 Ring 创建语法: new Konva.Ring( config ) 常用属性: innerRadius, outerRadiusclockwise案例 var ring = new Konva.Ring({x: width / 2,y: height / 2,innerRadius: 50,outerRadius: 100,fill: ‘pink’,stroke: ‘blue’,});layer.add( ring );效果 2.10. 圆弧 Arc 创建语法: new Konva.Arc( config ) 常用属性: innerRadius, outerRadiusangle案例 var arc = new Konva.Arc({x: width / 2,y: height / 2,innerRadius: 70,outerRadius: 100,stroke: ‘green’,fill: ‘pink’,angle: 60,rotation: -90});layer.add( arc );效果 2.11. 正多边形 Regular Polygon 创建语法: new Konva.RegularPolygon( config ) 常用属性: sides 属性. 表示多边形的边数.radius 属性.案例 var shape = new Konva.RegularPolygon({x: width / 2, y: height / 2,sides: 6,radius: 100,fill: ‘pink’,stroke: ‘blue’});layer.add( shape );效果 2.12. 箭头 Arrow 创建语法: new Konva.Arrow( config ) 常用属性: points 属性tension 属性pointerLength 属性. 表示箭头的长度.pointerWidth 属性. 表示箭头的宽度.案例 var rect1 = new Konva.Rect({x: width / 4 - 50,y: height / 4 - 25,stroke: ‘#000’,width: 100,height: 50,fill: ‘pink’,opacity: .5});layer.add( rect1 ); var txt1 = new Konva.Text({x: width / 4 - 50,y: height / 4 - 6,fontSize: 12,text: ‘Object 构造函数’,align: ‘center’,width: 100,height: 50});layer.add( txt1 ); var rect2 = new Konva.Rect({x: width 3 / 4 - 50,y: height 3 / 4 - 25,stroke: ‘#000’,width: 100,height: 50,fill: ‘pink’,opacity: .5});layer.add( rect2 ); var txt2 = new Konva.Text({x: width 3 / 4 - 50,y: height 3 / 4 - 6,fontSize: 12,text: ‘Object.prototype’,align: ‘center’,width: 100,height: 50});layer.add( txt2 ); var arrow = new Konva.Arrow({points: [width / 4 + 50,height / 4, width / 2,height / 4, width / 2,height * 3 / 4, width 3 / 4 - 50 - 7,height 3 / 4],pointerLength: 15,pointerWidth: 6,fill: ‘#ccc’,stroke: ‘#ccc’,lineWidth: .7}); layer.add( arrow );效果 组 Group创建语法: new Konva.Group( config ) 常用属性: x, y, width, heightrotation, draggable案例 var group = new Konva.Group({x: 100, y: 100,width: 100,height: 100});layer.add( group );group.add( new Konva.Rect({x: 0, y: 0, width: 100, height: 100,fill: ‘red’, stroke: ‘blue’}) );注意: 放在 group 中的形状使用 group 作为参考坐标.","tags":[{"name":"KonvaJs","slug":"KonvaJs","permalink":"http://liufusong.github.io/tags/KonvaJs/"}]},{"title":"github","date":"2017-04-07T16:00:00.000Z","path":"2017/04/08/git上传github/","text":"摘要: github git使用ssh方式上传代码与github git生成公钥和私钥 命令:ssh-keygen -t rsa生成的公钥与私钥文件会在当用户目录的.ssh目录下. 把代码push到服务器时需要先pull一下 在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。 从服务器上pull代码到本地 如果本地没有.git目录，需要先初始化一下。 命令:git pull [远程服务器地址] [远程的分支] gh-pages分支-搭建博客. 需要把自已博客的网页代码上传到github上的gh-pages分支 然后就直接访问了 访问的url形式: [github用户名].github.io/[仓库的名字]/[具体的页面] sourceTree , tortoiseGitnpm 官网[https://www.npmjs.com] node package manager 命令: 初始化:npm init 安装指定包:npm install jquery --save 删除指定包:npm remove jquery --save 下载安装package.json中dependencies属性对的文件:npm install --production browser-sync 更改代码之后自动刷新浏览器 需要使用npm进行全局安装:npm install browser-sync -g,-g表示安装到全局 使用:browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot; –files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。 gulp 官网 中文网 前端自动化构建工具js压缩,var x,xname，混淆合并.css压缩html压压缩 grunt ,webpack… 核心就5个方法 task,gulp中是一个个任务的形式来实现功能。 task(‘任务名’,function(){…..}); src src(‘./*.js’) dest(‘./minjs/‘)// 指定处理后的文件的输出路径. watch(‘./*.js’,[‘任务名1’,’任务名2’]); run(‘任务名’);//执行指定的任务. gulp的安装 使用npm 进行安装 npm install gulp-cli -g; gulp 使用使用时还需要在项目中通过npm非全局安装gulp npm install gulp --save-dev 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.gulp的一些插件 也是使用npm安装 对js代码进行压缩 gulp-uglify 对代码进行合并 gulp-concat 对css进行压缩 gulp-cssnano 对html进行压缩 gulp-htmlmin","tags":[{"name":"git","slug":"git","permalink":"http://liufusong.github.io/tags/git/"},{"name":"githug","slug":"githug","permalink":"http://liufusong.github.io/tags/githug/"}]},{"title":"git工具","date":"2017-04-07T16:00:00.000Z","path":"2017/04/08/git使用/","text":"摘要: Git是一款源代码管理工具(版本控制工具)正文: Git什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。1.0是稳定2.0加了新功能 源代码有必要管理起吗？ 有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。 svn,vss,vcs,tfs…..-Git是linux之父当年为了维护linux—linus之前也是手动维护合并把文件发给Linus BitKeeper(收费) 有人想破解(不给提供免费使用) linus自己写了一个版本管理的工具（Git） 分布式版本管理工具，集中式 git属于分布式 svn集中式 git安装git初始化一个仓库 其实就是创建了一个.git隐藏目录 命令:git init; 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令. 一般是在项目的根目录执行这个命令. 自报家门 配置用户名 : git config user.name &quot;testName&quot; 配置邮箱 : git config user.email &quot;test@sina.com&quot; 查看配置信息: git config --list 把代码提交到仓库中 1.先把代码添加到暂存区(就相当于放到仓库门口) 命令:git add 文件路径 示例:git add ./reademe.md 可以使用git add .这个命令，批量把当前目录下所有修改过的文件添加到暂存区。 2.把暂存区的文件提交仓库里 命令: git commit -m &quot;注释&quot; 示例: git commit -m &quot;我们添加了一个新的功能&quot; -m 表示指定一个字符串，作为提交的说明(相当于注释); 合并add 与commit 命令 git commit -a -m &quot;这是使用合并添加与提交的操作&quot;; 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用) 查看工作区状态 命令:git status 添加忽略文件 在项目中有一些文件是不需要提交的,我们需要把它忽略掉 需要在.git文件夹所在目录新建一个名为.gitignore的文件然后在这个文件中写上需要被忽略的文件的路径。示例: /css/a.css: /css/*.css : /a.html 比对文件差异 命令: git diff 用来比较工作区内容与最近一次提交的内容的区别 如果暂存区没有文件，就会将工作与代码与最近一次提交对比 命令：git diff --cached 比较暂存区的文件和仓库中文件的区别 对比之前某两次提交的文件的差异 命令:git diff [版本号1] [版本号2] [想比较的文件路径] 查看日志 命令:git log,可以查看每一次提交的日志 命令:git log --oneline 表示使用简洁的形式输出提交日志 版本回退 命令:git reset --hard Head~1 这是将代码回退到上上一次提交时的状态 命令:git reset --hard Head~2 回退到上上上次 命令:git reset --hard Head~0 回退到上次提交时的状态,~0可以省略 命令:git reset --hard 版本号 通过每次提交时生成的版本号来回退版本 通过git reflog命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。 创建分支 命令:git branch [分支名] 创建一个新分支 命令:git branch 查看当前所有的分支 切换分支 命令:git checkout [分支名] 切换分支后可以在切换后的分支中进行正常的操作 合并分支 命令:git merge [分支名] git会将指定的分支合并到当前分支. 删除分支 命令:git branch -d [分支名] 删除指定分支，-d参数表示要执行删除操作 git提交中的冲突 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交 githubgithub与git git 版本管理工具 github 就是一个网站，只是这个网站提供git服务器的功能 上传代码到git服务器(push) 命令:git push [远程服务器地址] [远程服务器的分支] 示例:git push https://github.com/huoqishi/test002.git master 上传时可以使用一些简化的命令 将远程服务器地址写成变量的形式 git remote add [变量名] [远程服务器地址] 示例:git remote add origin https://github.com/huoqishi/test002.git 这样之后就可以直接使用origin来代替git push 后面写的地址了git push origin master 还可以尽一步简化 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了git push origin; ###","tags":[{"name":"git","slug":"git","permalink":"http://liufusong.github.io/tags/git/"},{"name":"githug","slug":"githug","permalink":"http://liufusong.github.io/tags/githug/"}]}]