[{"title":"前端技术链接","date":"2017-04-17T06:54:20.000Z","path":"2017/04/17/前端技术链接/","text":"摘要: 前端技术链接 swiper移动端触摸滑动插件Framework7前端框架，是开发人员可以基于 web 技术构建 IOS7 程序css3loading动画图片懒加载SWEETALERT2-强大的纯JS模态消息对话框插件网站炫酷效果Node.js v6.10.2 文档MDN提供有关开放网络技术(Open Web)的信息前端笔记网","tags":[]},{"title":"hexo+github创建属于自己的博客","date":"2017-04-14T06:05:59.000Z","path":"2017/04/14/hexo-github创建属于自己的博客/","text":"摘要： hexo+github创建博客学不会就去吃翔 直接上实用的不罗嗦 配置环境安装Node（必须） 作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须） 作用：把本地的hexo内容提交到github上去. 安装Xcode就自带有Git，我就不多说了。 申请GitHub（必须） 作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。 正式安装HexoNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。 执行如下命令安装Hexo：1sudo npm install -g hexo 初始化然后，执行init命令初始化hexo,命令：1hexo init 好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。 生成静态页面1hexo generate（hexo g也可以） 本地启动 启动本地服务，进行文章预览调试，命令：1hexo server 浏览器输入http://localhost:4000 我不知道你们能不能，反正我不能，因为我还有环境没配置好 配置Github建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： vim _config.yml 翻到最下面，改成我这样子的 deploy: type: git repo: https://github.com/leopardpan/leopardpan.github.io.git branch: master 然后执行命令： npm install hexo-deployer-git --save 网上会有很多说法，有的type是github, 还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。 忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。 然后，执行配置命令： hexo deploy 然后再浏览器中输入https://liufusong.github.io/就行了，我的github的账户叫liufusong,把这个改成你github的账户名就行了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate hexo deploy 一些常用命令： hexo new&quot;postName&quot; #新建文章 hexo new page&quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 报错总结 ERROR Deployer not found: git 或者 ERROR Deployer not found: github 解决方法： npm install hexo-deployer-git –save 如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令： rm-rf.DS_Store ERROR Plugin load failed: hexo-server 原因： Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore. 解决方法，执行命令： sudo npm install hexo-server 执行命令hexo server，提示：Usage: hexo …. 原因： 我认为是没有生成本地服务 解决方法，执行命令： npm install hexo-server --save 提示：hexo-server@0.1.2 node_modules/hexo-server …. 表示成功了 这个时候再执行： hexo-server 得到: I NFOHexois running at http://0.0.0.0:4000/.PressCtrl+C to stop. 这个时候再点击http://0.0.0.0:4000，正常情况下应该是最原始的画面，但是我看到的是： 白板和Cannot GET / 几个字 原因： 由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令： npm install hexo-renderer-ejs --save npm install hexo-renderer-stylus --save npm install hexo-renderer-marked --save 这个时候再重新生成静态文件，命令： hexo generate（或hexo g） 启动本地服务器： hexo server（或hexo s） 再，点击http://0.0.0.0:4000,OK终于可以看到属于你自己的blog啦，😄，虽然很简陋，但好歹有了一个属于自己的小窝了，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。","tags":[]},{"title":"angular工作中最常用的几种功能","date":"2017-04-12T13:54:19.000Z","path":"2017/04/12/angular工作中最常用的几种功能/","text":"摘要： AngularJS 最常用的功能 第一动态绑定之ng-model 任何有用户输入，只要是有值的html标签，都可以动态绑定 举个栗子 &lt;input type=&quot;text&quot; ng-model=&#39;password&#39;&gt;。 将input的值与 password 进行绑定,下面你就可以通{ { } }过拿到input的值。 &lt;span&gt;{ { password } }&lt;/span&gt;第二迭代输出之ng-repeat标签 ng-repeat让table ul ol等标签和js里的数组完美结合 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul 你甚至可以指定输出的顺序：","tags":[]},{"title":"正则表达式","date":"2017-04-11T09:22:25.000Z","path":"2017/04/11/正则表达式/","text":"摘要: 正则表达式的基本使用 本文目标 让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。如何使用本教程 别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？正则表达式到底是什么东西？ 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。很可能你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。入门 学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。 假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。 这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。 不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。 \\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。 假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.*\\bLucy\\b。 这里，.是另一个元字符，匹配除了换行符以外的任意字符。同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。 0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。 这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。 为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。 元字符 现在你已经知道几个很有用的元字符了，如\\b,.,*，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。 下面来看看更多的例子：\\ba\\w\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w)，最后是单词结束处(\\b)。 \\d+匹配1个或更多连续的数字。这里的+是和类似的元字符，不同的是匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\\b\\w{6}\\b 匹配刚好6个字符的单词。表1.常用的元字符代码 说明. 匹配除换行符以外的任意字符\\w 匹配字母或数字或下划线或汉字\\s 匹配任意的空白符\\d 匹配数字\\b 匹配单词的开始或结束^ 匹配字符串的开始$ 匹配字符串的结束 元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。 字符转义 如果你想查找元字符本身的话，比如你查找.,或者,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和\\。当然，要查找\\本身，你也得用\\.例如：deerchao\\.net匹配deerchao.net，C:\\\\Windows匹配C:\\Windows。重复 你已经看过了前面的,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如,{5,12}等)：表2.常用的限定符代码/语法 说明 重复零次或更多次 重复一次或更多次? 重复零次或一次{n} 重复n次{n,} 重复n次或更多次{n,m} 重复n到m次下面是一些使用重复的例子：Windows\\d+匹配Windows后面跟1个或更多数字^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)字符类 要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。下面是一个更复杂的表达式：(?0\\d{2}[) -]?\\d{8}。 这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或 - 或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。分枝条件 不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。(?0\\d{2})?[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\\d{5}-\\d{4}|\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。分组 我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。(\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。 不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。理解这个表达式的关键是理解2[0-4]\\d|25[0-5]|[01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。反义 有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：表3.常用的反义代码代码/语法 说明\\W 匹配任意不是字母，数字，下划线，汉字的字符\\S 匹配任意不是空白符的字符\\D 匹配任意非数字的字符\\B 匹配不是单词开头或结束的位置[^x] 匹配除了x以外的任意字符[^aeiou] 匹配除了aeiou这几个字母以外的任意字符例子：\\S+匹配不包含空白符的字符串。]+&gt;匹配用尖括号括起来的以a开头的字符串。##","tags":[]},{"title":"KonvaJS中文文档","date":"2017-04-08T12:14:54.000Z","path":"2017/04/08/KonvaJS中文文档/","text":"摘要: Konva 是一个 基于 Canvas 开发的 2d js 框架库, 它可以轻松的实现桌面应用和移动应用中的图形交互交互效果正文: KonvaJS Konva 是一个 基于 Canvas 开发的 2d js 框架库, 它可以轻松的实现桌面应用和移动应用中的图形交互交互效果. Konva 可以高效的实现动画, 变换, 节点嵌套, 局部操作, 滤镜, 缓存, 事件等功能, 不仅仅适用于桌面与移动开发, 还有更为广泛的应用. Konva 允许在舞台上绘图, 添加事件监听, 移动或缩放某个图形, 独立旋转, 以及高效的动画. 即使应用中含有数千个图形也是可以轻松实现的. 1.1. 使用 Konva 打开链接 http://konvajs.github.io/, 下载 KonvaJS 代码. 开发中为了方便调试, 使用完全版. 实际使用使用压缩版. 使用 script 标签导入需要使用的 Konva 库. &lt;script src=&quot;konva.js&quot;&gt;&lt;/script&gt; 1.2. KonvaJS 的理念 任何图形都存在于舞台中( Konva.Stage ). 这个舞台中又可以包多个用户层( Konva.Layer ). 每一个层中都含有两个 canvas 着色器: 一个前台渲染器, 一个后台渲染器. 前台渲染器是可以看见的部分,而后台渲染器是一个隐藏的 canvas. 后台渲染器为了提高效率实现事件监听的工作. 每一个层可以包含形状( Shape ), 形状的组( Group ), 甚至是由组组成的组. 舞台, 层, 组, 以及形状都是虚拟的节点( node ). 类似于 HTML 页面中的 DOM 节点. 在这个图形中, 首先有一个舞台( Stage ). 该舞台在页面中与整个页面的大小一样. 然后舞台中有一个层( Layer ). 层中有一个矩形( Rect )和一个圆形( Circle ). 因此就有一个树结构:所有的节点都可以设置样式与变化. 即使 Konva 可以重新渲染形状, 例如: 矩形, 圆形, 图片, 精灵, 文本, 线段, 多边形, 正多边形, 路径, 和星星等. 但是开发者依旧可以根据 Shape 类的模板自定义自己的图形, 然后重写 draw 方法.只要拥有了 舞台( Stage ), 并且上面放置了层( Layer )和图形( Shape ), 那么就可以为他添加事件监听, 变换节点, 运行动画, 使用路径, 甚至是更多的效果.###例如要实现上面的案例: 需要引入 Konva.js 文件&lt;script src=&quot;konva.js&quot;&gt;&lt;/script&gt; 然后页面中放置一个容器作为 Konva 处理的对象. Konva 会在该容器中添加 canvas 标签. 值得说明的是, 需要为这个标签添加 id 属性.&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt; 然后编写 js 代码. Konva 是一个完全面向对象的库.创建舞台var stage = new Konva.Stage({ container: &apos;dv&apos;, width: window.innerWidth, height: window.innerHeight }); 首先, 在 Konva 中所有的图形都是在 Konva 中的一个构造函数. Konva 是全局的命名空间.创建舞台使用的是 Stage 构造函数. 该函数需要提供参数.Konva 中所有图形的参数都是使用 json 对象的方式进行提供.舞台需要设置容器的 id, 即 container 属性. 以及宽( width ), 高( height ).舞台中可以放置一个到多个层( Layer ), 所有的图形应该放在在层中.首先创建层对象. 层对象不需要传递参数.var layer = new Konva.Layer();将层添加到舞台中. Konva 中凡是添加, 都是使用 add 方法.stage.add( layer );在层中放置一个矩形, 就创建一个 矩形对象.矩形对象需要四个参数来确定, 分别是 左上角的两个坐标, 和 宽与高.var rect = new Konva.Rect({x: 100,y: 50,width: 200,height: 100,fill: ‘red’});Konva 中添加颜色使用 fill 属性和 stroke 属性, 分别表示填充颜色与描边颜色.将矩形添加到 层中layer.add( rect );在层中添加一个圆形, 使用构造函数 Circlevar circle = new Konva.Circle({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: 100,fill: ‘pink’,stroke: ‘blue’});layer.add( circle );Konva 中使用 radius 设置圆形的半径.Konva 中如果需要获取对象的数据, 使用 getXXX 方法. 传入参数即设置, 不传参数就是获取数据.最后绘图使用 draw 方法layer.draw();1.3. 基本形状 Konva.js 支持的形状有: 矩形( Rect ), 圆形( Circle ), 椭圆( Rllipse ), 线段( Line ), 图像( Image ), 文本( Text ), 文本路径( TextPath ), 星星( Start ), 标签( Label ), SVG 路径( SVG Path ), 正多边形( RegularPolygon ). 同时也可以自定义形状. 自定义形状使用 Shape 构造函数创建需要提供自定义的绘图方法 sceneFuncvar triangle = new Konva.Shape({sceneFunc: function ( ctx ) {// 自定义绘图路径ctx.moveTo( window.innerWidth / 2, window.innerHeight / 4 );ctx.lineTo( window.innerWidth / 2 - window.innerHeight / ( 2 1.732 ), window.innerHeight 3 / 4 );ctx.lineTo( window.innerWidth / 2 + window.innerHeight / ( 2 1.732 ), window.innerHeight 3 / 4 );ctx.closePath();// Konva.js 的独有方法ctx.fillStrokeShape( this );},fill: ‘pink’,stroke: ‘red’});将图形添加后绘图layer.add( triangle );layer.draw(); 1.4. 样式 所有的形状都支持下列样式属性: 填充. 颜色, 渐变或图片.描边. 颜色与宽度.阴影. 颜色, 偏移量, 透明度与模糊透明度1.4.1. 绘制正五边形 构造函数: Konva.RegularPolygon( options ) 常用属性: x, y. 表示正多边形的中心坐标.sides. 表示正多边形的边数.radius. 表示半径.fill. 填充颜色.stroke. 描边的颜色.strokeWidth. 描边的宽度.shadowOffsetX 和 shadowOffsety. 描述背景的偏移量.shadowBlur. 表示模糊程度.opacity. 表示透明度( 取值在 0, 1 之间 ).案例 var shape = new Konva.RegularPolygon({x: stage.getWidth() / 2,y: stage.getHeight() / 2,sides: 5,radius: 70,fill: ‘red’,stroke: ‘black’,strokeWidth: 4,shadowOffsetX: 20,shadowOffsetY: 25,shadowBlurBlur: 40,opacity: 0.5});layer.add( shape ); 1.5. 事件 使用 Konva 可以轻松的实现监听用户添加的事件. 例如 click, dblclick, mouseover, tap, dbltap, touchstart 等. 属性值变化事件. 例如 scaleXChange, fillChange 等. 以及拖拽事件. 例如 dragstart, dragmove, dragend. 代码 circle.on( ‘mouseout touchend’, function () {console.log( ‘用户输入’ );});circle.on( ‘xChange’, function () {console.log( ‘位置发生改变’ );});circle.on( ‘dragend’, function () {console.log( ‘拖动停止’ );});1.6. 拖拽与降低 Konva 支持拖拽的功能. 也支持下降事件( drop, dropenter, dropleave, dropover ). 如果需要实现拖拽的功能. 可以设置 draggable 属性为 true. 创建的时候设置属性创建后使用方法设置属性shape.draggable( true );Konva 还支持给拖拽事件添加移动范围. 1.7. 滤镜( Filter ) Konva 支持多种滤镜功能. 例如: 模糊, 翻转, 声音等. 1.8. 动画 Konva 中可以使用两种方式创建动画 使用 Konva.Animationvar anim = new Konva.Animation(function ( frame ) {var time = frame.time,timeDiff = frame.timeDiff,frameRate = frame.frameRate;// 更新代码}, layer );使用 Konva.Tween var tween = new Konva.Tween({node: rect,duration: 1,x: 140,rotation: Math.PI * 2,opacity: 1,strokeWidth: 6}); // 或者使用新的短方法circle.to({duration: 1,fill: ‘green’});1.9. 选择器 当构建规模较大的应用时, 如果可以对元素进行搜索是非常方便的. Konva 使用选择器来实现元素的查找. 使用 find() 方法返回一个集合. 使用 findOne() 方法返回集合中的第 0 个元素. 给元素提供 name 属性, 可以使用 ‘.name’ 来进行获取. 类似于类选择器.使用构造函数的名字也可以作为名字选择器. 类似于标签选择器.使用 id 属性, 则使用 ‘#id’ 来获取.查找方法使用层对象来调用.案例 …var r = 100;var c1 = new Konva.Circle({x: stage.getWidth() / 8,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,id: ‘c1’});layer.add( c1 ); var c2 = new Konva.Circle({x: stage.getWidth() / 8 * 3,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,name: ‘c’});layer.add( c2 ); var c3 = new Konva.Circle({x: stage.getWidth() / 8 * 5,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,name: ‘c’});layer.add( c3 ); var c3 = new Konva.Circle({x: stage.getWidth() / 8 * 7,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’});layer.add( c3 ); layer.find( ‘.c’ ).each(function ( v, i ) {v.fill( ‘pink’ );}); layer.find( ‘#c1’ ).forEach(function ( v, i ) {v.stroke( ‘blue’ );v.strokeWidth( 10 );}); layer.find( ‘Circle’ ).each( function ( v, i ) {v.stroke( ‘green’ );});…1.10. 序列号与反序列化 所有被创建的对象都可以保存为 JSON 对象. 可以在服务器或本地存储中使用它. var json = stage.toJSON();同时, 也可以从 JSON 中恢复 Konva 对象. var json = ‘{“attrs”:{“width”:578,”height”:200},’ +‘“className”:”Stage”, ‘ +‘“children”:[{ ‘ +‘“attrs”:{},’ +‘“className”:”Layer”,’ +‘“children”:[ ‘ +‘{“attrs”:{ ‘ +‘“x”:100,”y”:100,’ +‘“sides”:6,”radius”:70,’ +‘“fill”:”red”,”stroke”:”black”,’ +‘“strokeWidth”:4},’ +‘“className”:”RegularPolygon”}’ +‘]’ +‘}]}’;var stage = Konva.Node.create(json, ‘container’); 形状 Shape2.1. 矩形 Rect 创建语法: new Konva.Rect( config ) 常用属性: cornerRadius 属性. 数字类型, 表示圆角矩形的圆角半径.fill 属性. 字符串, 设置填充颜色.stroke 属性. 字符串, 设置描边颜色.dash 属性. 数组, 用于描述虚线的间隔.x, y, width, height 属性. 数字, 描述矩形的位置与宽高.name, id 属性. 字符串, 用于设置搜索标记.opacity 属性. 数字, 用于设置透明度.scaleX, scaleY 属性. 数字, 用于设置缩放变换.rotation 属性. 数字, 用于设置旋转角度.draggable 属性. 布尔类型, 用于设置是否允许拖拽.lineJoin, lineCap 属性. 设置线样式.常用方法: Konva 中构造函数的属性多半有同名的方法.toJSON() 方法. 将动画转换成 json 字符串.to( params ) 方法. 使用 Tween 动画.setAttrs( config ) 与 setAttr( attr, val ) 方法, 用于重新设置属性.remove() 方法. 将当前对象删除, 但是销毁.on( evtStr, handler ) 与 off( evtStr ) 方法, 用于添加与移除事件.案例 …var rect = new Konva.Rect({x: 100, y: 100,width: 200, height: 100,stroke: ‘red’, fill: ‘pink’});layer.add( rect );…2.2. 圆 Circle 创建语法: new Konva.Circle( config ) 常用属性: radius 属性. 数字类型, 用于设置半径.fill, stroke 属性.strokeWidth 属性.lineJoin, lineCap 属性.dash 属性.x, y 属性常用方法: 2.3. 椭圆 Ellipse 创建语法: new Konva.Ellipse( config ). 常用属性: x, y 属性. 数字类型, 表示椭圆中心的坐标radius 属性. 对象类型, x, y 分别表示椭圆的长轴与短轴.案例 var ellipse = new Konva.Ellipse({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: {x: 100, y: 100},stroke: ‘red’,fill: ‘pink’,rotation: 30});效果 2.4. 楔形 Wedge 创建语法: new Konva.Wedge( config ) 常用属性: angle 属性. 表示楔形的角度. 角度带有方向, 水平向右为 0 度. 使用角度单位.radius 属性. 表示半径.clockwise 属性. 表示方向.x, y, lineJoin, lineCap, fill, stroke, …常用方法: 案例 …var data = [ .3, .4, .2, .1 ];var colors = ‘red, pink, green, blue’.split( ‘,’ );var startAngle = -90;data.forEach( function ( v, i ) {var wedge = new Konva.Wedge({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: 100,angle: startAngle + 360 * v,rotation: startAngle,fill: colors[ i ],opacity: .8}); startAngle += 360 * v;layer.add( wedge );});…效果 2.5. 线段 Line 线段有折现, 曲线与闭合线路的用法. 创建语法: new Konva.Line( config ) 常用属性: points 属性. 数组, 用于存储折线的各个点的坐标.tension 属性. 数字类型, 用于表示曲线连线. 默认为 0.closed 属性. 布尔值, 用于表示是否闭合路径.x, y 属性. 用于设置绘制直线时的参考坐标原点.常用方法: 说明: 使用 Konva.Line 构造函数创建直线.使用 Konva.Line 构造函数与 closed = true 属性可以创建多边形.使用 Konva.Line 构造函数与 tension 属性可以创建曲线板.使用 Konva.Line 构造函数与 tension 属性, 以及 closed = true 可以创建气泡.案例 var line = new Konva.Line({x: 100, y: 100,points: [ 10, 0, 100, 100, 200, 0 ],tension: 1,stroke: ‘red’});layer.add( line ); var rect = new Konva.Line({x: 300, y: 100,points: [ 0, 0, 100, 0, 100, 100, 0, 100 ],closed: true,stroke: ‘red’});layer.add( rect );效果 2.6. 图片 Image 创建语法: new Konva.Image( config ) 常用属性: x, y, width, heightimage 属性. 用于设置图片对象.crop 属性. 对象: { x, y, width, height }. 表示裁剪.2.7. 文本 Text 创建语法: new Konva.Text( config ) 常用属性: fontFamily 属性.fontSize 属性.fontStyle 属性.fontVariant 属性text 属性. 用于设置文本内容.align 属性. 可选值: left, center, right.padding 属性.lineHeight 属性.x, y 属性案例 // 创建文本var txt = new Konva.Text({x: 100, y: 100,align: ‘left’,text: ‘测试文本’,fontSize: 30,padding: 10,width: 200,height: 200 });layer.add( txt ); var rect = new Konva.Rect({x: 100, y: 100,width: 200, height: 200,stroke: ‘red’});layer.add( rect );效果 2.8. 星星 Star 创建语法: new Konva.Star( config ) 常用属性: x, ynumPoints 属性. 表示 几角星.innerRadius 属性. 表示内半径.outerRadius 属性. 表示外半径.旋转的五角星 var star = new Konva.Star({x: stage.getWidth() / 2,y: stage.getHeight() / 2,numPoints: 5,outerRadius: 100,innerRadius: 50,stroke: ‘red’,fill: ‘lightgreen’});layer.add( star ); var tween = new Konva.Tween({node: star,rotation: 360,duration: 2,onFinish: function () {this.reset();this.play();}});tween.play();效果 2.9. 圆环 Ring 创建语法: new Konva.Ring( config ) 常用属性: innerRadius, outerRadiusclockwise案例 var ring = new Konva.Ring({x: width / 2,y: height / 2,innerRadius: 50,outerRadius: 100,fill: ‘pink’,stroke: ‘blue’,});layer.add( ring );效果 2.10. 圆弧 Arc 创建语法: new Konva.Arc( config ) 常用属性: innerRadius, outerRadiusangle案例 var arc = new Konva.Arc({x: width / 2,y: height / 2,innerRadius: 70,outerRadius: 100,stroke: ‘green’,fill: ‘pink’,angle: 60,rotation: -90});layer.add( arc );效果 2.11. 正多边形 Regular Polygon 创建语法: new Konva.RegularPolygon( config ) 常用属性: sides 属性. 表示多边形的边数.radius 属性.案例 var shape = new Konva.RegularPolygon({x: width / 2, y: height / 2,sides: 6,radius: 100,fill: ‘pink’,stroke: ‘blue’});layer.add( shape );效果 2.12. 箭头 Arrow 创建语法: new Konva.Arrow( config ) 常用属性: points 属性tension 属性pointerLength 属性. 表示箭头的长度.pointerWidth 属性. 表示箭头的宽度.案例 var rect1 = new Konva.Rect({x: width / 4 - 50,y: height / 4 - 25,stroke: ‘#000’,width: 100,height: 50,fill: ‘pink’,opacity: .5});layer.add( rect1 ); var txt1 = new Konva.Text({x: width / 4 - 50,y: height / 4 - 6,fontSize: 12,text: ‘Object 构造函数’,align: ‘center’,width: 100,height: 50});layer.add( txt1 ); var rect2 = new Konva.Rect({x: width 3 / 4 - 50,y: height 3 / 4 - 25,stroke: ‘#000’,width: 100,height: 50,fill: ‘pink’,opacity: .5});layer.add( rect2 ); var txt2 = new Konva.Text({x: width 3 / 4 - 50,y: height 3 / 4 - 6,fontSize: 12,text: ‘Object.prototype’,align: ‘center’,width: 100,height: 50});layer.add( txt2 ); var arrow = new Konva.Arrow({points: [width / 4 + 50,height / 4, width / 2,height / 4, width / 2,height * 3 / 4, width 3 / 4 - 50 - 7,height 3 / 4],pointerLength: 15,pointerWidth: 6,fill: ‘#ccc’,stroke: ‘#ccc’,lineWidth: .7}); layer.add( arrow );效果 组 Group创建语法: new Konva.Group( config ) 常用属性: x, y, width, heightrotation, draggable案例 var group = new Konva.Group({x: 100, y: 100,width: 100,height: 100});layer.add( group );group.add( new Konva.Rect({x: 0, y: 0, width: 100, height: 100,fill: ‘red’, stroke: ‘blue’}) );注意: 放在 group 中的形状使用 group 作为参考坐标. KonvaJS Konva 是一个 基于 Canvas 开发的 2d js 框架库, 它可以轻松的实现桌面应用和移动应用中的图形交互交互效果. Konva 可以高效的实现动画, 变换, 节点嵌套, 局部操作, 滤镜, 缓存, 事件等功能, 不仅仅适用于桌面与移动开发, 还有更为广泛的应用. Konva 允许在舞台上绘图, 添加事件监听, 移动或缩放某个图形, 独立旋转, 以及高效的动画. 即使应用中含有数千个图形也是可以轻松实现的. 1.1. 使用 Konva 打开链接 http://konvajs.github.io/, 下载 KonvaJS 代码.开发中为了方便调试, 使用完全版. 实际使用使用压缩版.使用 script 标签导入需要使用的 Konva 库. 1.2. KonvaJS 的理念 任何图形都存在于舞台中( Konva.Stage ). 这个舞台中又可以包多个用户层( Konva.Layer ). 每一个层中都含有两个 着色器: 一个前台渲染器, 一个后台渲染器. 前台渲染器是可以看见的部分, 而后台渲染器是一个隐藏的 canvas. 后台渲染器为了提高效率实现事件监听的工作. 每一个层可以包含形状( Shape ), 形状的组( Group ), 甚至是由组组成的组. 舞台, 层, 组, 以及形状都是虚拟的节点( node ). 类似于 HTML 页面中的 DOM 节点. 在这个图形中, 首先有一个舞台( Stage ). 该舞台在页面中与整个页面的大小一样. 然后舞台中有一个层( Layer ). 层中有一个矩形( Rect )和一个圆形( Circle ). 因此就有一个树结构: 所有的节点都可以设置样式与变化. 即使 Konva 可以重新渲染形状, 例如: 矩形, 圆形, 图片, 精灵, 文本, 线段, 多边形, 正多边形, 路径, 和星星等. 但是开发者依旧可以根据 Shape 类的模板自定义自己的图形, 然后重写 draw 方法. 只要拥有了 舞台( Stage ), 并且上面放置了层( Layer )和图形( Shape ), 那么就可以为他添加事件监听, 变换节点, 运行动画, 使用路径, 甚至是更多的效果. 例如要实现上面的案例: 需要引入 Konva.js 文件 然后页面中放置一个容器作为 Konva 处理的对象. Konva 会在该容器中添加 canvas 标签. 值得说明的是, 需要为这个标签添加 id 属性. 然后编写 js 代码. Konva 是一个完全面向对象的库.创建舞台var stage = new Konva.Stage({container: ‘dv’,width: window.innerWidth,height: window.innerHeight});首先, 在 Konva 中所有的图形都是在 Konva 中的一个构造函数. Konva 是全局的命名空间.创建舞台使用的是 Stage 构造函数. 该函数需要提供参数.Konva 中所有图形的参数都是使用 json 对象的方式进行提供.舞台需要设置容器的 id, 即 container 属性. 以及宽( width ), 高( height ).舞台中可以放置一个到多个层( Layer ), 所有的图形应该放在在层中.首先创建层对象. 层对象不需要传递参数.var layer = new Konva.Layer();将层添加到舞台中. Konva 中凡是添加, 都是使用 add 方法.stage.add( layer );在层中放置一个矩形, 就创建一个 矩形对象.矩形对象需要四个参数来确定, 分别是 左上角的两个坐标, 和 宽与高.var rect = new Konva.Rect({x: 100,y: 50,width: 200,height: 100,fill: ‘red’});Konva 中添加颜色使用 fill 属性和 stroke 属性, 分别表示填充颜色与描边颜色.将矩形添加到 层中layer.add( rect );在层中添加一个圆形, 使用构造函数 Circlevar circle = new Konva.Circle({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: 100,fill: ‘pink’,stroke: ‘blue’});layer.add( circle );Konva 中使用 radius 设置圆形的半径.Konva 中如果需要获取对象的数据, 使用 getXXX 方法. 传入参数即设置, 不传参数就是获取数据.最后绘图使用 draw 方法layer.draw();1.3. 基本形状 Konva.js 支持的形状有: 矩形( Rect ), 圆形( Circle ), 椭圆( Rllipse ), 线段( Line ), 图像( Image ), 文本( Text ), 文本路径( TextPath ), 星星( Start ), 标签( Label ), SVG 路径( SVG Path ), 正多边形( RegularPolygon ). 同时也可以自定义形状. 自定义形状使用 Shape 构造函数创建需要提供自定义的绘图方法 sceneFuncvar triangle = new Konva.Shape({sceneFunc: function ( ctx ) {// 自定义绘图路径ctx.moveTo( window.innerWidth / 2, window.innerHeight / 4 );ctx.lineTo( window.innerWidth / 2 - window.innerHeight / ( 2 1.732 ), window.innerHeight 3 / 4 );ctx.lineTo( window.innerWidth / 2 + window.innerHeight / ( 2 1.732 ), window.innerHeight 3 / 4 );ctx.closePath();// Konva.js 的独有方法ctx.fillStrokeShape( this );},fill: ‘pink’,stroke: ‘red’});将图形添加后绘图layer.add( triangle );layer.draw(); 1.4. 样式 所有的形状都支持下列样式属性: 填充. 颜色, 渐变或图片.描边. 颜色与宽度.阴影. 颜色, 偏移量, 透明度与模糊透明度1.4.1. 绘制正五边形 构造函数: Konva.RegularPolygon( options ) 常用属性: x, y. 表示正多边形的中心坐标.sides. 表示正多边形的边数.radius. 表示半径.fill. 填充颜色.stroke. 描边的颜色.strokeWidth. 描边的宽度.shadowOffsetX 和 shadowOffsety. 描述背景的偏移量.shadowBlur. 表示模糊程度.opacity. 表示透明度( 取值在 0, 1 之间 ).案例 var shape = new Konva.RegularPolygon({x: stage.getWidth() / 2,y: stage.getHeight() / 2,sides: 5,radius: 70,fill: ‘red’,stroke: ‘black’,strokeWidth: 4,shadowOffsetX: 20,shadowOffsetY: 25,shadowBlurBlur: 40,opacity: 0.5});layer.add( shape ); 1.5. 事件 使用 Konva 可以轻松的实现监听用户添加的事件. 例如 click, dblclick, mouseover, tap, dbltap, touchstart 等. 属性值变化事件. 例如 scaleXChange, fillChange 等. 以及拖拽事件. 例如 dragstart, dragmove, dragend. 代码 circle.on( ‘mouseout touchend’, function () {console.log( ‘用户输入’ );});circle.on( ‘xChange’, function () {console.log( ‘位置发生改变’ );});circle.on( ‘dragend’, function () {console.log( ‘拖动停止’ );});1.6. 拖拽与降低 Konva 支持拖拽的功能. 也支持下降事件( drop, dropenter, dropleave, dropover ). 如果需要实现拖拽的功能. 可以设置 draggable 属性为 true. 创建的时候设置属性创建后使用方法设置属性shape.draggable( true );Konva 还支持给拖拽事件添加移动范围. 1.7. 滤镜( Filter ) Konva 支持多种滤镜功能. 例如: 模糊, 翻转, 声音等. 1.8. 动画 Konva 中可以使用两种方式创建动画 使用 Konva.Animationvar anim = new Konva.Animation(function ( frame ) {var time = frame.time,timeDiff = frame.timeDiff,frameRate = frame.frameRate;// 更新代码}, layer );使用 Konva.Tween var tween = new Konva.Tween({node: rect,duration: 1,x: 140,rotation: Math.PI * 2,opacity: 1,strokeWidth: 6}); // 或者使用新的短方法circle.to({duration: 1,fill: ‘green’});1.9. 选择器 当构建规模较大的应用时, 如果可以对元素进行搜索是非常方便的. Konva 使用选择器来实现元素的查找. 使用 find() 方法返回一个集合. 使用 findOne() 方法返回集合中的第 0 个元素. 给元素提供 name 属性, 可以使用 ‘.name’ 来进行获取. 类似于类选择器.使用构造函数的名字也可以作为名字选择器. 类似于标签选择器.使用 id 属性, 则使用 ‘#id’ 来获取.查找方法使用层对象来调用.案例 …var r = 100;var c1 = new Konva.Circle({x: stage.getWidth() / 8,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,id: ‘c1’});layer.add( c1 ); var c2 = new Konva.Circle({x: stage.getWidth() / 8 * 3,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,name: ‘c’});layer.add( c2 ); var c3 = new Konva.Circle({x: stage.getWidth() / 8 * 5,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’,name: ‘c’});layer.add( c3 ); var c3 = new Konva.Circle({x: stage.getWidth() / 8 * 7,y: stage.getHeight() / 2,radius: r,fill: ‘red’,stroke: ‘#000’});layer.add( c3 ); layer.find( ‘.c’ ).each(function ( v, i ) {v.fill( ‘pink’ );}); layer.find( ‘#c1’ ).forEach(function ( v, i ) {v.stroke( ‘blue’ );v.strokeWidth( 10 );}); layer.find( ‘Circle’ ).each( function ( v, i ) {v.stroke( ‘green’ );});…1.10. 序列号与反序列化 所有被创建的对象都可以保存为 JSON 对象. 可以在服务器或本地存储中使用它. var json = stage.toJSON();同时, 也可以从 JSON 中恢复 Konva 对象. var json = ‘{“attrs”:{“width”:578,”height”:200},’ +‘“className”:”Stage”, ‘ +‘“children”:[{ ‘ +‘“attrs”:{},’ +‘“className”:”Layer”,’ +‘“children”:[ ‘ +‘{“attrs”:{ ‘ +‘“x”:100,”y”:100,’ +‘“sides”:6,”radius”:70,’ +‘“fill”:”red”,”stroke”:”black”,’ +‘“strokeWidth”:4},’ +‘“className”:”RegularPolygon”}’ +‘]’ +‘}]}’;var stage = Konva.Node.create(json, ‘container’); 形状 Shape2.1. 矩形 Rect 创建语法: new Konva.Rect( config ) 常用属性: cornerRadius 属性. 数字类型, 表示圆角矩形的圆角半径.fill 属性. 字符串, 设置填充颜色.stroke 属性. 字符串, 设置描边颜色.dash 属性. 数组, 用于描述虚线的间隔.x, y, width, height 属性. 数字, 描述矩形的位置与宽高.name, id 属性. 字符串, 用于设置搜索标记.opacity 属性. 数字, 用于设置透明度.scaleX, scaleY 属性. 数字, 用于设置缩放变换.rotation 属性. 数字, 用于设置旋转角度.draggable 属性. 布尔类型, 用于设置是否允许拖拽.lineJoin, lineCap 属性. 设置线样式.常用方法: Konva 中构造函数的属性多半有同名的方法.toJSON() 方法. 将动画转换成 json 字符串.to( params ) 方法. 使用 Tween 动画.setAttrs( config ) 与 setAttr( attr, val ) 方法, 用于重新设置属性.remove() 方法. 将当前对象删除, 但是销毁.on( evtStr, handler ) 与 off( evtStr ) 方法, 用于添加与移除事件.案例 …var rect = new Konva.Rect({x: 100, y: 100,width: 200, height: 100,stroke: ‘red’, fill: ‘pink’});layer.add( rect );…2.2. 圆 Circle 创建语法: new Konva.Circle( config ) 常用属性: radius 属性. 数字类型, 用于设置半径.fill, stroke 属性.strokeWidth 属性.lineJoin, lineCap 属性.dash 属性.x, y 属性常用方法: 2.3. 椭圆 Ellipse 创建语法: new Konva.Ellipse( config ). 常用属性: x, y 属性. 数字类型, 表示椭圆中心的坐标radius 属性. 对象类型, x, y 分别表示椭圆的长轴与短轴.案例 var ellipse = new Konva.Ellipse({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: {x: 100, y: 100},stroke: ‘red’,fill: ‘pink’,rotation: 30});效果 2.4. 楔形 Wedge 创建语法: new Konva.Wedge( config ) 常用属性: angle 属性. 表示楔形的角度. 角度带有方向, 水平向右为 0 度. 使用角度单位.radius 属性. 表示半径.clockwise 属性. 表示方向.x, y, lineJoin, lineCap, fill, stroke, …常用方法: 案例 …var data = [ .3, .4, .2, .1 ];var colors = ‘red, pink, green, blue’.split( ‘,’ );var startAngle = -90;data.forEach( function ( v, i ) {var wedge = new Konva.Wedge({x: stage.getWidth() / 2,y: stage.getHeight() / 2,radius: 100,angle: startAngle + 360 * v,rotation: startAngle,fill: colors[ i ],opacity: .8}); startAngle += 360 * v;layer.add( wedge );});…效果 2.5. 线段 Line 线段有折现, 曲线与闭合线路的用法. 创建语法: new Konva.Line( config ) 常用属性: points 属性. 数组, 用于存储折线的各个点的坐标.tension 属性. 数字类型, 用于表示曲线连线. 默认为 0.closed 属性. 布尔值, 用于表示是否闭合路径.x, y 属性. 用于设置绘制直线时的参考坐标原点.常用方法: 说明: 使用 Konva.Line 构造函数创建直线.使用 Konva.Line 构造函数与 closed = true 属性可以创建多边形.使用 Konva.Line 构造函数与 tension 属性可以创建曲线板.使用 Konva.Line 构造函数与 tension 属性, 以及 closed = true 可以创建气泡.案例 var line = new Konva.Line({x: 100, y: 100,points: [ 10, 0, 100, 100, 200, 0 ],tension: 1,stroke: ‘red’});layer.add( line ); var rect = new Konva.Line({x: 300, y: 100,points: [ 0, 0, 100, 0, 100, 100, 0, 100 ],closed: true,stroke: ‘red’});layer.add( rect );效果 2.6. 图片 Image 创建语法: new Konva.Image( config ) 常用属性: x, y, width, heightimage 属性. 用于设置图片对象.crop 属性. 对象: { x, y, width, height }. 表示裁剪.2.7. 文本 Text 创建语法: new Konva.Text( config ) 常用属性: fontFamily 属性.fontSize 属性.fontStyle 属性.fontVariant 属性text 属性. 用于设置文本内容.align 属性. 可选值: left, center, right.padding 属性.lineHeight 属性.x, y 属性案例 // 创建文本var txt = new Konva.Text({x: 100, y: 100,align: ‘left’,text: ‘测试文本’,fontSize: 30,padding: 10,width: 200,height: 200 });layer.add( txt ); var rect = new Konva.Rect({x: 100, y: 100,width: 200, height: 200,stroke: ‘red’});layer.add( rect );效果 2.8. 星星 Star 创建语法: new Konva.Star( config ) 常用属性: x, ynumPoints 属性. 表示 几角星.innerRadius 属性. 表示内半径.outerRadius 属性. 表示外半径.旋转的五角星 var star = new Konva.Star({x: stage.getWidth() / 2,y: stage.getHeight() / 2,numPoints: 5,outerRadius: 100,innerRadius: 50,stroke: ‘red’,fill: ‘lightgreen’});layer.add( star ); var tween = new Konva.Tween({node: star,rotation: 360,duration: 2,onFinish: function () {this.reset();this.play();}});tween.play();效果 2.9. 圆环 Ring 创建语法: new Konva.Ring( config ) 常用属性: innerRadius, outerRadiusclockwise案例 var ring = new Konva.Ring({x: width / 2,y: height / 2,innerRadius: 50,outerRadius: 100,fill: ‘pink’,stroke: ‘blue’,});layer.add( ring );效果 2.10. 圆弧 Arc 创建语法: new Konva.Arc( config ) 常用属性: innerRadius, outerRadiusangle案例 var arc = new Konva.Arc({x: width / 2,y: height / 2,innerRadius: 70,outerRadius: 100,stroke: ‘green’,fill: ‘pink’,angle: 60,rotation: -90});layer.add( arc );效果 2.11. 正多边形 Regular Polygon 创建语法: new Konva.RegularPolygon( config ) 常用属性: sides 属性. 表示多边形的边数.radius 属性.案例 var shape = new Konva.RegularPolygon({x: width / 2, y: height / 2,sides: 6,radius: 100,fill: ‘pink’,stroke: ‘blue’});layer.add( shape );效果 2.12. 箭头 Arrow 创建语法: new Konva.Arrow( config ) 常用属性: points 属性tension 属性pointerLength 属性. 表示箭头的长度.pointerWidth 属性. 表示箭头的宽度.案例 var rect1 = new Konva.Rect({x: width / 4 - 50,y: height / 4 - 25,stroke: ‘#000’,width: 100,height: 50,fill: ‘pink’,opacity: .5});layer.add( rect1 ); var txt1 = new Konva.Text({x: width / 4 - 50,y: height / 4 - 6,fontSize: 12,text: ‘Object 构造函数’,align: ‘center’,width: 100,height: 50});layer.add( txt1 ); var rect2 = new Konva.Rect({x: width 3 / 4 - 50,y: height 3 / 4 - 25,stroke: ‘#000’,width: 100,height: 50,fill: ‘pink’,opacity: .5});layer.add( rect2 ); var txt2 = new Konva.Text({x: width 3 / 4 - 50,y: height 3 / 4 - 6,fontSize: 12,text: ‘Object.prototype’,align: ‘center’,width: 100,height: 50});layer.add( txt2 ); var arrow = new Konva.Arrow({points: [width / 4 + 50,height / 4, width / 2,height / 4, width / 2,height * 3 / 4, width 3 / 4 - 50 - 7,height 3 / 4],pointerLength: 15,pointerWidth: 6,fill: ‘#ccc’,stroke: ‘#ccc’,lineWidth: .7}); layer.add( arrow );效果 组 Group创建语法: new Konva.Group( config ) 常用属性: x, y, width, heightrotation, draggable案例 var group = new Konva.Group({x: 100, y: 100,width: 100,height: 100});layer.add( group );group.add( new Konva.Rect({x: 0, y: 0, width: 100, height: 100,fill: ‘red’, stroke: ‘blue’}) );注意: 放在 group 中的形状使用 group 作为参考坐标.","tags":[]},{"title":"github","date":"2017-04-07T16:00:00.000Z","path":"2017/04/08/git上传github/","text":"摘要: github git使用ssh方式上传代码与github git生成公钥和私钥 命令:ssh-keygen -t rsa生成的公钥与私钥文件会在当用户目录的.ssh目录下. 把代码push到服务器时需要先pull一下 在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。 从服务器上pull代码到本地 如果本地没有.git目录，需要先初始化一下。 命令:git pull [远程服务器地址] [远程的分支] gh-pages分支-搭建博客. 需要把自已博客的网页代码上传到github上的gh-pages分支 然后就直接访问了 访问的url形式: [github用户名].github.io/[仓库的名字]/[具体的页面] sourceTree , tortoiseGitnpm 官网[https://www.npmjs.com] node package manager 命令: 初始化:npm init 安装指定包:npm install jquery --save 删除指定包:npm remove jquery --save 下载安装package.json中dependencies属性对的文件:npm install --production browser-sync 更改代码之后自动刷新浏览器 需要使用npm进行全局安装:npm install browser-sync -g,-g表示安装到全局 使用:browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot; –files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。 gulp 官网 中文网 前端自动化构建工具js压缩,var x,xname，混淆合并.css压缩html压压缩 grunt ,webpack… 核心就5个方法 task,gulp中是一个个任务的形式来实现功能。 task(‘任务名’,function(){…..}); src src(‘./*.js’) dest(‘./minjs/‘)// 指定处理后的文件的输出路径. watch(‘./*.js’,[‘任务名1’,’任务名2’]); run(‘任务名’);//执行指定的任务. gulp的安装 使用npm 进行安装 npm install gulp-cli -g; gulp 使用使用时还需要在项目中通过npm非全局安装gulp npm install gulp --save-dev 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.gulp的一些插件 也是使用npm安装 对js代码进行压缩 gulp-uglify 对代码进行合并 gulp-concat 对css进行压缩 gulp-cssnano 对html进行压缩 gulp-htmlmin","tags":[]},{"title":"git工具","date":"2017-04-07T16:00:00.000Z","path":"2017/04/08/git使用/","text":"摘要: Git是一款源代码管理工具(版本控制工具)正文: Git什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。1.0是稳定2.0加了新功能 源代码有必要管理起吗？ 有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。 svn,vss,vcs,tfs…..-Git是linux之父当年为了维护linux—linus之前也是手动维护合并把文件发给Linus BitKeeper(收费) 有人想破解(不给提供免费使用) linus自己写了一个版本管理的工具（Git） 分布式版本管理工具，集中式 git属于分布式 svn集中式 git安装git初始化一个仓库 其实就是创建了一个.git隐藏目录 命令:git init; 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令. 一般是在项目的根目录执行这个命令. 自报家门 配置用户名 : git config user.name &quot;testName&quot; 配置邮箱 : git config user.email &quot;test@sina.com&quot; 查看配置信息: git config --list 把代码提交到仓库中 1.先把代码添加到暂存区(就相当于放到仓库门口) 命令:git add 文件路径 示例:git add ./reademe.md 可以使用git add .这个命令，批量把当前目录下所有修改过的文件添加到暂存区。 2.把暂存区的文件提交仓库里 命令: git commit -m &quot;注释&quot; 示例: git commit -m &quot;我们添加了一个新的功能&quot; -m 表示指定一个字符串，作为提交的说明(相当于注释); 合并add 与commit 命令 git commit -a -m &quot;这是使用合并添加与提交的操作&quot;; 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用) 查看工作区状态 命令:git status 添加忽略文件 在项目中有一些文件是不需要提交的,我们需要把它忽略掉 需要在.git文件夹所在目录新建一个名为.gitignore的文件然后在这个文件中写上需要被忽略的文件的路径。示例: /css/a.css: /css/*.css : /a.html 比对文件差异 命令: git diff 用来比较工作区内容与最近一次提交的内容的区别 如果暂存区没有文件，就会将工作与代码与最近一次提交对比 命令：git diff --cached 比较暂存区的文件和仓库中文件的区别 对比之前某两次提交的文件的差异 命令:git diff [版本号1] [版本号2] [想比较的文件路径] 查看日志 命令:git log,可以查看每一次提交的日志 命令:git log --oneline 表示使用简洁的形式输出提交日志 版本回退 命令:git reset --hard Head~1 这是将代码回退到上上一次提交时的状态 命令:git reset --hard Head~2 回退到上上上次 命令:git reset --hard Head~0 回退到上次提交时的状态,~0可以省略 命令:git reset --hard 版本号 通过每次提交时生成的版本号来回退版本 通过git reflog命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。 创建分支 命令:git branch [分支名] 创建一个新分支 命令:git branch 查看当前所有的分支 切换分支 命令:git checkout [分支名] 切换分支后可以在切换后的分支中进行正常的操作 合并分支 命令:git merge [分支名] git会将指定的分支合并到当前分支. 删除分支 命令:git branch -d [分支名] 删除指定分支，-d参数表示要执行删除操作 git提交中的冲突 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交 githubgithub与git git 版本管理工具 github 就是一个网站，只是这个网站提供git服务器的功能 上传代码到git服务器(push) 命令:git push [远程服务器地址] [远程服务器的分支] 示例:git push https://github.com/huoqishi/test002.git master 上传时可以使用一些简化的命令 将远程服务器地址写成变量的形式 git remote add [变量名] [远程服务器地址] 示例:git remote add origin https://github.com/huoqishi/test002.git 这样之后就可以直接使用origin来代替git push 后面写的地址了git push origin master 还可以尽一步简化 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了git push origin; ###","tags":[]}]